Based on the sources provided, here is the list of 90 SQL coding questions from the book "Cracking the SQL Interview for Data Scientists". The questions are organized into the three main sections as they appear in the book.
Single Table Operations
This section includes 41 questions that are categorized under single table operations.
Question 1. Top store for movie sales (easy): Write a query to return the name of the store and its manager that generated the most sales.
Question 2. Top 3 movie categories by sales (easy): Write a query to find the top 3 film categories that generated the most sales.
Question 3. Top 5 shortest movies (easy): Write a query to return the titles of the 5 shortest movies by duration.
Question 4. Staff without a profile image (easy): Write a SQL query to return the first name and last name of the staff member who doesn't have a profile picture.
Question 5. Monthly revenue (easy): Write a query to return the total movie rental revenue for each month.
Question 6. Daily revenue in June, 2020 (easy): Write a query to return daily revenue in June 2020.
Question 7. Unique customers count by month (easy): Write a query to return the total number of unique customers for each month.
Question 8. Average customer spend by month (medium): Write a query to return the average customer spend by month, defined as total spend divided by the unique number of customers.
Question 9. Number of high spend customers by month (medium): Write a query to count the number of customers who spend more than $20 by month.
Question 10. Min and max spend (medium): Write a query to return the minimum and maximum customer total spend in June 2020.
Question 11. Actors' last name (easy): Find the number of actors whose last name is 'DAVIS', 'BRODY', 'ALLEN', or 'BERRY'.
Question 12. Actors' last name ending in 'EN' or 'RY' (easy): Identify and count all actors whose last name ends in 'EN' or 'RY', grouped by their last name.
Question 13. Actors' first name (medium): Return the number of actors grouped into categories based on the first letter of their first name ('A', 'B', 'C', or others).
Question 14. Good days and bad days (difficult): Return the number of "good days" (> 100 rentals) and "bad days" (<= 100 rentals) in May 2020.
Question 15. Fast movie watchers vs slow watchers (difficult): Return the number of "fast watchers" (average return within 5 days) vs "slow watchers" (average return >5 days).
Question 16. Staff who live in Woodridge (easy): Write a query to return the names of the staff who live in the city of 'Woodridge'.
Question 17. GROUCHO WILLIAMS’ actor_id (easy): Write a query to return GROUCHO WILLIAMS' actor_id.
Question 18. Top film category (easy): Return the film category id with the most films and the count of films in that category.
Question 19. Most productive actor (medium): Return the first and last name of the actor who appeared in the most films.
Question 20. Customer who spent the most (medium): Return the first and last name of the customer who spent the most on movie rentals in February 2020.
Question 21. Customer who rented the most (medium): Return the first and last name of the customer who made the most rental transactions in May 2020.
Question 22. Average cost per rental transaction (easy): Return the average cost per movie rental transaction in May 2020.
Question 23. Average spend per customer in Feb 2020 (easy): Return the average movie rental spend per customer in February 2020.
Question 24. Films with more than 10 actors (medium): Return the titles of films with 10 or more actors.
Question 25. Shortest film (easy): Return the title of the film with the minimum duration.
Question 26. Second shortest film (medium): Return the title of the second shortest film by duration.
Question 27. Film with the largest cast (easy): Return the title of the film with the most actors.
Question 28. Film with the second largest cast (medium): Return the title of the film with the second largest cast.
Question 29. Second highest spend customer (medium): Return the name of the customer who had the second-highest spend in May 2020.
Question 30. Inactive customers in May (easy): Return the total number of customers who did not rent any movies in May 2020.
Question 31. Movies that have not been returned (easy): Return the titles of films that have not been returned by customers.
Question 32. Unpopular movies (difficult): Return the number of films with no rentals in February 2020.
Question 33. Returning customers (medium): Return the number of customers who rented at least one movie in both May 2020 and June 2020.
Question 34. Stocked up movies (easy): Return the titles of movies with more than 7 DVD copies in inventory.
Question 35. Film length report (easy): Return the number of films categorized as short (<60 min), medium (60-99 min), and long (>=100 min).
Question 81. How many people searched on new year's day (easy): Return the total number of users who searched on January 1, 2021.
Question 82. The top search query on new year's day (easy): Return the top search term on January 1, 2021.
Question 84. Click through rate on new year's day (easy): Compute the click-through rate (searches with at least one click) for search results on January 1, 2021.
Question 85. Top 5 queries based on click through rate on new year's day (difficult): Return the top 5 search terms with the highest click-through rate on January 1, 2021, for queries searched by more than two distinct users.
Question 86. Top song in the US (easy): Return the name of the top song in the US yesterday.
Question 89. Top 5 artists in the US (medium): Return the top 5 artist IDs for the US yesterday.
Multi-Table Operations
This section contains 23 questions focusing on combining data from multiple tables.
Question 36. Actors from film 'AFRICAN EGG' (easy): Return the names of all actors in the film 'AFRICAN EGG'.
Question 37. Most popular movie category (easy): Return the name of the category that has the most films.
Question 38. Most popular movie category (name and id) (medium): Return the name and ID of the most popular film category.
Question 39. Most productive actor with inner join (easy): Using an INNER JOIN, return the name of the actor who appears in the most films.
Question 40. Top 5 most rented movie in June 2020 (medium): Return the film ID and title of the top 5 most-rented movies in June 2020.
Question 41. Productive actors vs less-productive actors (medium): Return the number of "productive" (>=30 films) and "less-productive" (<30 films) actors.
Question 42. Films that are in stock vs not in stock (medium): Return the number of films that have inventory versus those that do not.
Question 43. Customers who rented vs. those who did not (medium): Return the number of customers who rented at least one movie versus those who didn't in May 2020.
Question 44. In-demand vs not-in-demand movies (medium): Return the number of "in-demand" (>1 rental) and "not-in-demand" (<=1 rental) movies in May 2020.
Question 45. Movie inventory optimization (difficult): Return the number of unique inventory IDs for movies with zero rentals in May 2020.
Question 46. Actors and customers whose last name starts with 'A' (easy): Return the unique names of customers and actors whose last name starts with 'A'.
Question 47. Actors and customers whose first names end in 'D'. (easy): Return the IDs and names of all actors and customers whose first names end in 'D'.
Question 48. Movie and TV actors (easy): Return actors who appeared in both TV and movies.
Question 49. Top 3 money making movie categories (medium): Return the names and rental revenues of the top 3 movie categories.
Question 50. Top 5 cities for movie rentals (easy): Return the names and revenues of the top 5 cities with the most rental revenues in 2020.
Question 51. Movie only actor (easy): Return the names of actors who have only appeared in movies.
Question 52. Movies cast by movie only actors (difficult): Return the film IDs for movies cast only by actors who have never appeared in TV.
Question 53. Movie groups by rental income (difficult): Return the number of films grouped by rental income: high (>= $100), medium ($20-$99), and low (< $20).
Question 54. Customer groups by movie rental spend (medium): Return the number of customers grouped by total rental spend: high (>= $150), medium ($100-$149), and low (< $100).
Question 55. Busy days and slow days (medium): Return the number of "busy" (>= 100 rentals) and "slow" (< 100 rentals) days in May 2020.
Question 56. Total number of actors (easy): Using a FULL OUTER JOIN, return the total number of unique actors from TV and movie tables.
Question 57. Total number of actors (with UNION) (easy): Using UNION, return the total number of unique actors from TV and movie tables.
Question 87. Top song in the US and UK (medium): Return the name of the top song in the US and UK yesterday, respectively.
Window Functions
This section features 26 questions that require the use of advanced window functions.
Question 58. Percentage of revenue per movie (medium): For films with film_id <= 10, return the percentage of total revenue each film represents.
Question 59. Percentage of revenue per movie by category (medium): For films with film_id <= 10, return the percentage of revenue each film represents within its own category.
Question 60. Movie rentals and average rentals in the same category (medium): For films with film_id <= 10, return the number of rentals for each movie alongside the average rentals for its category.
Question 61. Customer spend vs average spend in the same store (difficult): For a specific list of customers, return their lifetime spend and the average lifetime spend of all customers in the same store.
Question 62. Shortest film by category (medium): Return the shortest movie from each category.
Question 63. Top 5 customers by store (medium): Return the top 5 customers and their rankings based on their spending for each store.
Question 64. Top 2 films by category (difficult): Return the top 2 films based on rental revenue within their respective categories.
Question 65. Movie revenue percentiles (easy): For a specific list of films, return their percentile distribution based on total rental revenue.
Question 66. Movie percentiles by revenue by category (medium): For films with film_id <= 20, generate a percentile distribution based on total rental revenue within their category.
Question 67. Quartile by number of rentals (easy): For a specific list of films, return their quartile buckets based on the number of rentals.
Question 68. Spend difference between first and second rentals (difficult): For a specific list of customers, calculate the difference in spending between their first and second rentals.
Question 69. Number of happy customers (difficult): Return the number of "happy customers" who made at least one rental on two consecutive days between May 24 and May 31.
Question 70. Cumulative spend (easy): For specific customers, return their cumulative daily spending.
Question 71. Cumulative rentals (easy): For specific customers, return their cumulative daily rentals.
Question 72. Days when they became happy customers (easy): For specific customers, return the date they became a "happy customer" (made at least 10 rentals).
Question 73. Number of days to become a happy customer (medium): Return the average number of days it takes for a customer to make their 10th rental.
Question 74. The most productive actors by category (medium): For each movie category, return the actor who has appeared in the most movies in that category.
Question 75. Top customer by movie category (medium): For each movie category, return the customer ID who spent the most.
Question 76. Districts with the most and least customers (easy): Return the districts that have the most and the least number of customers.
Question 77. Movie revenue percentiles by category (easy): For a specific list of films, return their revenue percentiles within their category.
Question 78. Quartiles buckets by number of rentals (medium): For a specific list of customers, return their quartile bucket based on their number of rentals.
Question 79. Spend difference between the last and the second last rentals (difficult): For specific customers, return the spending difference between their last and second-to-last movie rentals.
Question 80. DoD revenue growth for each store (difficult): Return the day-over-day (DoD) revenue growth percentage for each store from May 24 to May 31.
Question 83. Top search_query in US and UK on new year's day (medium): Return the top searched term in the US and UK separately for January 1, 2021.
Question 88. Top song report (medium): Return the top song ID for every country.
Question 90. Top artist report (medium): Return the top artist ID for every country.


Two Advanced SQL Techniques That Can Drastically Improve Your Queries
Learn about Common Table Expression (CTE) and Window Functions

Jason Chong
Jun 30, 2023
10 min read
Share
Photo by Karina Szczurek on Unsplash
Photo by Karina Szczurek on Unsplash
SQL is the bread and butter of every data professional. It doesn’t matter if you are a data analyst, data scientist, or data engineer, you need to have a solid understanding of how to write clean and efficient SQL queries.

This is because behind any rigorous data analysis or any sophisticated machine learning model is the underlying data itself, and this data has to come from somewhere.

Hopefully after reading my introductory blog post to SQL, you would have already learned that SQL stands for Structured Query Language and it is a language that is used to retrieve data from a relational database.

In that blog post, we went over some fundamental SQL commands such as SELECT, FROM, and WHERE which should cover most of the basic queries you will come across when using SQL.

But what happens if those simple commands are simply not enough? What happens if the data you want demands a more robust approach to query?

Well, look no further because today, we will go over two new SQL techniques that you can add to your toolkit that will take your queries to the next level. These techniques are called Common Table Expression (CTE) and Window Functions.

To help us learn these techniques, we will be using an online SQL editor called DB Fiddle (set to SQLite v3.39) and the taxi trip duration dataset sourced from Google Cloud (NYC Open Data license).

Data Preparation
If you are not interested to learn how I prepared the dataset, feel free to skip past this section and paste the following code onto DB fiddle to generate the schema.

CREATE TABLE taxi (
  id varchar,
  vendor_id integer,
  pickup_datetime datetime,
  dropoff_datetime datetime,
  trip_seconds integer,
  distance float
);

INSERT INTO taxi 
VALUES
('id2875421', 2, '2016-03-14 17:24:55', '2016-03-14 17:32:30', 455, 0.93), 
('id2377394', 1, '2016-06-12 00:43:35', '2016-06-12 00:54:38', 663, 1.12), 
('id3858529', 2, '2016-01-19 11:35:24', '2016-01-19 12:10:48', 2124, 3.97), 
('id3504673', 2, '2016-04-06 19:32:31', '2016-04-06 19:39:40', 429, 0.92), 
('id2181028', 2, '2016-03-26 13:30:55', '2016-03-26 13:38:10', 435, 0.74), 
('id0801584', 2, '2016-01-30 22:01:40', '2016-01-30 22:09:03', 443, 0.68), 
('id1813257', 1, '2016-06-17 22:34:59', '2016-06-17 22:40:40', 341, 0.82), 
('id1324603', 2, '2016-05-21 07:54:58', '2016-05-21 08:20:49', 1551, 3.55), 
('id1301050', 1, '2016-05-27 23:12:23', '2016-05-27 23:16:38', 255, 0.82), 
('id0012891', 2, '2016-03-10 21:45:01', '2016-03-10 22:05:26', 1225, 3.19), 
('id1436371', 2, '2016-05-10 22:08:41', '2016-05-10 22:29:55', 1274, 2.37), 
('id1299289', 2, '2016-05-15 11:16:11', '2016-05-15 11:34:59', 1128, 2.35), 
('id1187965', 2, '2016-02-19 09:52:46', '2016-02-19 10:11:20', 1114, 1.16), 
('id0799785', 2, '2016-06-01 20:58:29', '2016-06-01 21:02:49', 260, 0.62), 
('id2900608', 2, '2016-05-27 00:43:36', '2016-05-27 01:07:10', 1414, 3.97), 
('id3319787', 1, '2016-05-16 15:29:02', '2016-05-16 15:32:33', 211, 0.41), 
('id3379579', 2, '2016-04-11 17:29:50', '2016-04-11 18:08:26', 2316, 2.13), 
('id1154431', 1, '2016-04-14 08:48:26', '2016-04-14 09:00:37', 731, 1.58), 
('id3552682', 1, '2016-06-27 09:55:13', '2016-06-27 10:17:10', 1317, 2.86), 
('id3390316', 2, '2016-06-05 13:47:23', '2016-06-05 13:51:34', 251, 0.81), 
('id2070428', 1, '2016-02-28 02:23:02', '2016-02-28 02:31:08', 486, 1.56), 
('id0809232', 2, '2016-04-01 12:12:25', '2016-04-01 12:23:17', 652, 1.07), 
('id2352683', 1, '2016-04-09 03:34:27', '2016-04-09 03:41:30', 423, 1.29), 
('id1603037', 1, '2016-06-25 10:36:26', '2016-06-25 10:55:49', 1163, 3.03), 
('id3321406', 2, '2016-06-03 08:15:05', '2016-06-03 08:56:30', 2485, 12.82), 
('id0129640', 2, '2016-02-14 13:27:56', '2016-02-14 13:49:19', 1283, 2.84), 
('id3587298', 1, '2016-02-27 21:56:01', '2016-02-27 22:14:51', 1130, 3.77), 
('id2104175', 1, '2016-06-20 23:07:16', '2016-06-20 23:18:50', 694, 2.33), 
('id3973319', 2, '2016-06-13 21:57:27', '2016-06-13 22:12:19', 892, 1.57), 
('id1410897', 1, '2016-03-23 14:10:39', '2016-03-23 14:49:30', 2331, 6.18);
After running SELECT * from taxi, you should get a resulting table that looks like this.

Image by Author.
Image by Author.
For the keen beans who are wondering how this table actually came about, I filtered the data to the first 30 rows and only kept the columns that you see above. As for the distance field, I computed the orthodromic distance between the pick-up and drop-off coordinates (latitude and longitude).

The orthodromic distance is the shortest distance between two points on a sphere, so this actually turns out to be an underestimate of the real distance travelled by the taxi. However, for the purpose of what we are doing today, we can ignore this for now.

The formula to calculate the orthodromic distance can be found here. Now, back to SQL.

Common Table Expression (CTE)
A common table expression (CTE) is a temporary table that you return within a query. You can think of it as a query within a query. They help to not only split your queries into more readable chunks but you can write new queries based on a CTE that has been defined.

To demonstrate this, suppose we want to analyze taxi trips split by the hour of the day and filter to trips that took place between the months of January and March 2016.

SELECT CAST(STRFTIME('%H', pickup_datetime) AS INT) AS hour_of_day, 
       trip_seconds,
       distance
FROM taxi
WHERE pickup_datetime > '2016-01-01'
  AND pickup_datetime < '2016-04-01'
ORDER BY hour_of_day;
Image by Author.
Image by Author.
Straightforward enough; let’s take this one step further.

Suppose now we want to compute the number of trips and the average speed for each of these hours. This is where we can utilize a CTE to first obtain a temporary table like the one we observe above, followed by a subsequent query to count the number of trips and compute the average speed group by hour of the day.

The way you would define a CTE is by using the WITH and AS statements.

WITH relevantrides AS
(
SELECT CAST(STRFTIME('%H', pickup_datetime) AS INT) AS hour_of_day, 
       trip_seconds,
       distance
FROM taxi
WHERE pickup_datetime > '2016-01-01'
  AND pickup_datetime < '2016-04-01'
ORDER BY hour_of_day
)
SELECT hour_of_day,
       COUNT(1) AS num_trips,
       ROUND(3600 * SUM(distance) / SUM(trip_seconds), 2) AS avg_speed
FROM relevantrides
GROUP BY hour_of_day
ORDER BY hour_of_day;
Image by Author.
Image by Author.
An alternative to using a CTE is simply wrapping the temporary table within a FROM statement (see code below), which would give you the same result. However, this is not advisable from a code readability standpoint. Moreover, imagine if we wanted to create more than just one temporary table.

SELECT hour_of_day,
       COUNT(1) AS num_trips,
       ROUND(3600 * SUM(distance) / SUM(trip_seconds), 2) AS avg_speed
FROM (
 SELECT CAST(STRFTIME('%H', pickup_datetime) AS INT) AS hour_of_day, 
           trip_seconds,
           distance
 FROM taxi
 WHERE pickup_datetime > '2016-01-01'
    AND pickup_datetime < '2016-04-01'
 ORDER BY hour_of_day
)
GROUP BY hour_of_day
ORDER BY hour_of_day;
Bonus: an interesting insight we can pull from this exercise is that taxis tend to move slower (lower average speed) during peak hours most likely due to heavier traffic as people travel to and back from work.

Window Functions
Window functions perform aggregate operations on groups of rows but they produce a result for each row in the original table.

To fully understand how window functions work, it is helpful to first do a quick recap of aggregation via GROUP BY.

Let’s say we wish to compute a list of summary statistics by month using the taxi dataset.

SELECT CAST(STRFTIME('%m', pickup_datetime) AS INT) AS month,
       COUNT(1) AS trip_count,
       ROUND(SUM(distance), 3) AS total_distance,
       ROUND(AVG(distance), 3) AS avg_distance,
       MIN(distance) AS min_distance,
       MAX(distance) AS max_distance
FROM taxi
GROUP BY month;
Image by Author.
Image by Author.
In the example above, we have computed the count, sum, average, minimum, and maximum distance travelled for each individual month in the dataset. Notice how our original taxi table with 30 rows has now been collapsed into six rows, one for each individual month.

So, what is actually happening behind the scenes? Firstly, SQL grouped all 30 rows in the original table based on their months. It then applied the relevant calculations based on the values in these individual groups.

Let’s take January as an example. There are two trips in the dataset that took place in the month of January, with distance travelled of 3.97 and 0.68 respectively. SQL then calculated the count, sum, average, minimum, and maximum based on these two values. The process then repeats for the other months until eventually we get an output that looks like the one above.

Now, hold this thought as we begin to explore how window functions work. There are three broad categories of window functions: aggregate functions, ranking functions, and navigation functions. We will look at examples of each one of them.

Aggregate functions
We have already seen aggregate functions at play in our previous example. Aggregate functions include functions like count, sum, average, minimum, and, maximum.

But where window functions differ from GROUP BY is the number of rows in the final output. Specifically, we saw that after aggregating by months, our output table is left with only six rows (one row for each distinct month).

Window functions, on the other hand, will not summarise the table by the aggregate field, but simply output the result in a new column for each row. The number of rows in the output table will not change. In other words, the output table will always have the same number of rows as the original table.

The syntax to perform a window function is OVER(PARTITION BY ...). You can think of this as the GROUP BY statement in our previous example.

Let’s see how this works in practice.

WITH aggregate AS
(
SELECT id,
       pickup_datetime,
       CAST(STRFTIME('%m', pickup_datetime) AS INT) AS month, 
       distance
FROM taxi
)
SELECT *,
       COUNT(1) OVER(PARTITION BY month) AS trip_count,
       ROUND(SUM(distance) OVER(PARTITION BY month), 3) AS total_month_distance,
       ROUND(AVG(distance) OVER(PARTITION BY month), 3) AS avg_month_distance,
       MIN(distance) OVER(PARTITION BY month) AS min_month_distance,
       MAX(distance) OVER(PARTITION BY month) AS max_month_distance
FROM aggregate;
Image by Author.
Image by Author.
Here, we want the same output as last time, but rather than collapsing the table, we want the output displayed as individual rows in a new column.

You would notice the values after the aggregation did not change but rather, they are simply displayed as repeated rows in the table. For example, the first two rows (January) have the same values for trip count, total month distance, average month distance, minimum month distance, and maximum month distance as before. The same applies to the other months.

In case you are wondering how window functions are useful, it helps us compare each row value with the aggregated value. In this instance, we can easily compare the distance travelled in each row with the monthly average, minimum and maximum, and so on.

Ranking functions
Another type of window function is the ranking function. As the name suggests, this ranks a group of rows based on an aggregate field.

WITH ranking AS
(
SELECT id,
       pickup_datetime,
       CAST(STRFTIME('%m', pickup_datetime) AS INT) AS month, 
       distance
FROM taxi
)
SELECT *,
       RANK() OVER(ORDER BY distance DESC) AS overall_rank,
       RANK() OVER(PARTITION BY month ORDER BY distance DESC) AS month_rank
FROM ranking
ORDER BY pickup_datetime;
Image by Author.
Image by Author.
In the example above, we have two ranking columns: one for the overall rank (from 1–30) and one for the monthly rank, both in descending order.

To specify the order when ranking, you will need to use ORDER BY within the OVER statement.

The way you would interpret the results for the first row is that it has the third-longest distance travelled in the whole dataset and the longest distance travelled for the month of January.

Navigation functions
Last but not least, we have navigation functions.

A navigation function assigns a value based on the value in a different row than the current row. Some common navigation functions include FIRST_VALUE, LAST_VALUE, LEAD, and LAG.

SELECT id,
       pickup_datetime,
       distance,
       LAG(distance) OVER(ORDER BY pickup_datetime) AS prev_distance,
       LEAD(distance) OVER(ORDER BY pickup_datetime) AS next_distance
FROM taxi
ORDER BY pickup_datetime;
Lag returns the value of the preceding row. Image by Author.
Lag returns the value of the preceding row. Image by Author.
Lead returns the value of the subsequent row. Image by Author.
Lead returns the value of the subsequent row. Image by Author.
In the example above, we used the LAG function to return the value of the preceding row and the LEAD function to return the value of the subsequent row. Notice how the first row of the lag column is null whereas the last row of the lead column is null.

SELECT id,
       pickup_datetime,
       distance,
       LAG(distance, 2) OVER(ORDER BY pickup_datetime) AS prev_distance,
       LEAD(distance, 2) OVER(ORDER BY pickup_datetime) AS next_distance
FROM taxi
ORDER BY pickup_datetime;
The first two rows are null when lag offset is set to 2. Image by Author.
The first two rows are null when lag offset is set to 2. Image by Author.
The last two rows are null when lead offset is set to 2. Image by Author.
The last two rows are null when lead offset is set to 2. Image by Author.
On a similar note, we can also offset the LEAD and LAG functions, i.e. to start from a particular index or position. When the offset is set to two, you can see that the first two rows of the lag column are null and the last two rows of the lead column are null.

I hope this blog post has helped introduce you to the concepts of Common Table Expression (CTE) and Window Functions.

To summarise, a CTE is a temporary table or a query within a query. They are used to split queries into more readable chunks and you can write new queries against a CTE that has been defined. Window functions, on the other hand, perform aggregation on groups of rows and return the results for each row in the original table.

If you wish to improve on these techniques, I highly encourage you to start implementing them in your SQL queries either at work, solving interview problems, or just playing around with random datasets. Practice makes perfect, am I right?


#1 Reframe the question and ask clarifying questions
Always start by confirming your understanding of the question. I do this by reframing the question in my own words. This shows my thought process and gives the interviewer a chance to correct me before I dive in. (Just in case I misunderstood or misinterpreted the question)

If the question involves some ambiguity, this is also your chance to clarify and align with your interviewer.

For example, if the interviewer asked you a question like: "What is the growth rate of X metric?"

There are so many ways to define growth:

→ Do we want absolute change or relative change?
→ Are we looking at long-term growth or short-term growth?

Use this first step as a chance to solidify how you will approach the question. This discussion shows off your product sense and great communication skills.

#2 State assumptions you have about the data
Typically, a SQL question would come with one or more tables. Before starting to write any queries, I find it helpful to state my assumptions on the table(s).

This step is so underrated, but it helps avoid misunderstandings and shows that you’re familiar with relational database concepts.

Some assumptions you can state include

Which column is the primary key?

Which columns are the foreign keys?

Can an event take place multiple times?

Are there any columns with unique values?

#3 Outline your approach
Again, you want to demonstrate your ability to communicate clearly and solve problems systematically.

I feel like a broken record saying the same thing over and over again. But the point I want to drive home is: you want to use your SQL interviews to demonstrate strong communication skills, and structured problem-solving approach.

There are a couple of good ways to outline your approach:

Bullet points → Outline the key steps you'll take (join tables, filter, aggregate, etc.)

Pseudocode → Quickly sketch out what the query will look like (especially useful if you’ll use multiple CTEs)

But if it’s a simple question, you don’t need to overdo it. Just talk through your approach out loud.

#4 Fill in your SQL query (talking aloud as you go)
Alright — now it’s time to actually write the query.

You’l be surprised how much easier this becomes because of all the steps you’ve completed before this. By now, you’ve already:

→ Clarified the question
→ Aligned on assumptions
→ Outlined your approach

At this point, your brain can go on auto-pilot as you fill in the blanks. As you code, talk through what you’re doing out loud, focusing on explaining your logic.

Side note, I personally also like doing this because it fills in the awkward silence.

#5 Review your query — catch any errors
In my opinion, this is the most important step.

I’ll say it again, this is the most important step.

Before you lock in your answer, take a minute to do a thorough review of your query.

Please… do not skip this step.

Why?

✅ Because if you catch the errors → that shows attention to detail.
❌ If your interviewer catches the errors → that shows a lack of skill.

Slow down here. It's worth it.

#6 Provide suggestions for improving the query
THIS is how you demonstrate that you’re a thought leader, and not a SQL monkey.

Finishing the query isn’t enough. That’s the baseline expectation.

You want to stand out from the crowd.

At the end of each query, answer at least one of these questions:

What are edge cases that the query did not catch?

What are some ways to optimize your query?

What are some drawbacks to this approach?


### Understanding the Role 
Based on the job description, this Senior Manager position in Advanced Analytics for Marketing 
at Airbnb involves leading a team of analysts to drive data-informed decisions in growth 
marketing and product strategy. You'll focus on advanced analysis, experimentation (including 
causal inference), building metrics and tools, and collaborating cross-functionally with teams 
like Data Science and Finance. It's remote-eligible in the US (with some restrictions on states), 
requires 12+ years in analytics/data science and 8+ in management, and prefers experience in 
marketplaces, statistical modeling, and tools like LLMs. Strong communication and stakeholder 
management are emphasized. 
To prepare effectively, I'll break this down into targeted sections: SQL technical prep, case 
study prep for product metrics, general interview tips, and additional resources. Since the 
interview simulates a real work environment (e.g., allowing syntax lookups), focus on 
conceptual understanding, problem-solving logic, and applying concepts to Airbnb-like 
scenarios (e.g., bookings, hosts, guests, marketing campaigns). 
### SQL Preparation 
The technical portion will cover basic to intermediate SQL, using dialects like Hive or Presto 
(which are similar to standard SQL but optimized for big data). Key concepts include: - **Joins**: INNER, LEFT, RIGHT, FULL, CROSS; handling multiple tables. - **Aggregating**: GROUP BY, COUNT, SUM, AVG, MAX/MIN; with HAVING for 
post-aggregation filters. - **Filtering**: WHERE clauses, conditional logic (CASE, IF). - **Subqueries**: Nested queries for filtering or aggregation. - **Self-joins**: Joining a table to itself, e.g., for hierarchical or time-based comparisons. - **Window functions**: ROW_NUMBER, RANK, LAG/LEAD, PARTITION BY for analytics over 
partitions. 
Practice by writing queries on hypothetical Airbnb datasets. Assume tables like: - `users` (user_id, signup_date, country) - `listings` (listing_id, host_id, city, price) - `bookings` (booking_id, guest_id, listing_id, booking_date, checkin_date, nights, revenue) - `campaigns` (campaign_id, user_id, exposure_date, type)  // For marketing exposure 
#### Practice Questions 
I'll provide 10 questions progressing from basic to intermediate, with Airbnb-themed contexts. 
Try solving them first, then check the solutions. Use online SQL sandboxes (e.g., DB-Fiddle) or 
tools like ChatGPT for syntax checks during practice. 
1. **Basic Filtering and Aggregation**: Find the total revenue from bookings in San Francisco in 
2024. - Solution: `SELECT SUM(revenue) AS total_revenue FROM bookings JOIN listings ON 
bookings.listing_id = listings.listing_id WHERE listings.city = 'San Francisco' AND 
YEAR(booking_date) = 2024;` 
2. **Joins**: List all users who have hosted at least one listing but never made a booking as a 
guest. - Solution: `SELECT u.user_id, u.signup_date FROM users u JOIN listings l ON u.user_id = 
l.host_id LEFT JOIN bookings b ON u.user_id = b.guest_id WHERE b.booking_id IS NULL 
GROUP BY u.user_id, u.signup_date HAVING COUNT(l.listing_id) >= 1;` 
3. **Subqueries**: Find listings with prices above the average price in their city. - Solution: `SELECT listing_id, city, price FROM listings WHERE price > (SELECT AVG(price) 
FROM listings AS sub WHERE sub.city = listings.city);` 
4. **Self-Joins**: Identify pairs of bookings by the same guest that occurred within 7 days of 
each other (e.g., for repeat travel patterns). - Solution: `SELECT b1.booking_id, b1.guest_id, b1.booking_date, b2.booking_id, 
b2.booking_date FROM bookings b1 JOIN bookings b2 ON b1.guest_id = b2.guest_id AND 
b1.booking_id < b2.booking_id WHERE DATEDIFF(b2.booking_date, b1.booking_date) <= 7;` 
5. **Window Functions (Basic)**: Rank listings by revenue within each city, showing the top 3 
per city. - Solution: `SELECT listing_id, city, revenue, RANK() OVER (PARTITION BY city ORDER BY 
revenue DESC) AS rank FROM (SELECT l.listing_id, l.city, SUM(b.revenue) AS revenue FROM 
listings l JOIN bookings b ON l.listing_id = b.listing_id GROUP BY l.listing_id, l.city) AS sub 
WHERE rank <= 3;` 
6. **Aggregating with Conditions**: Calculate the average nights stayed per booking, but only 
for users exposed to a 'discount' marketing campaign. - Solution: `SELECT AVG(nights) AS avg_nights FROM bookings b JOIN campaigns c ON 
b.guest_id = c.user_id WHERE c.type = 'discount';` 
7. **Subqueries in Joins**: Find the percentage of users who booked within 30 days of signup. - Solution: `SELECT (COUNT(DISTINCT b.guest_id) * 100.0 / COUNT(DISTINCT u.user_id)) 
AS conversion_rate FROM users u LEFT JOIN bookings b ON u.user_id = b.guest_id AND 
DATEDIFF(b.booking_date, u.signup_date) <= 30;` 
8. **Window Functions (Advanced)**: For each booking, calculate the running total revenue 
per host over time. - Solution: `SELECT host_id, booking_date, revenue, SUM(revenue) OVER (PARTITION BY 
host_id ORDER BY booking_date) AS running_total FROM bookings b JOIN listings l ON 
b.listing_id = l.listing_id ORDER BY host_id, booking_date;` 
9. **Self-Joins with Aggregation**: Compare monthly booking growth year-over-year for each 
city. - Solution: `SELECT curr.city, curr.month, curr.bookings, prev.bookings AS prev_bookings, 
(curr.bookings - prev.bookings) * 100.0 / prev.bookings AS growth_pct FROM (SELECT l.city, 
DATE_TRUNC('month', b.booking_date) AS month, COUNT(b.booking_id) AS bookings FROM 
bookings b JOIN listings l ON b.listing_id = l.listing_id GROUP BY l.city, month) curr LEFT JOIN 
(SELECT l.city, DATE_TRUNC('month', b.booking_date) AS month, COUNT(b.booking_id) AS 
bookings FROM bookings b JOIN listings l ON b.listing_id = l.listing_id GROUP BY l.city, month) 
prev ON curr.city = prev.city AND DATE_ADD(curr.month, INTERVAL -1 YEAR) = prev.month;` 
10. **Combined Concepts**: Using window functions and subqueries, find the top 5% of hosts 
by revenue contribution in the last year, with their share of total revenue. - Solution: `WITH host_revenue AS (SELECT host_id, SUM(revenue) AS total_revenue 
FROM bookings b JOIN listings l ON b.listing_id = l.listing_id WHERE YEAR(b.booking_date) = 
2024 GROUP BY host_id), ranked_hosts AS (SELECT host_id, total_revenue, NTILE(20) OVER 
(ORDER BY total_revenue DESC) AS percentile FROM host_revenue) SELECT host_id, 
total_revenue, (total_revenue / (SELECT SUM(total_revenue) FROM host_revenue)) * 100 AS 
revenue_share FROM ranked_hosts WHERE percentile = 1;` 
Tips for SQL Portion: - Practice explaining your query logic aloud—interviewers may ask why you chose a subquery 
over a join. - Handle edge cases: NULLs (use COALESCE), date functions (DATEADD, DATEDIFF), string 
manipulation (CONCAT, SUBSTRING). - If stuck, verbalize: "I'd look up the Presto syntax for window functions here." - Resources: LeetCode SQL problems (filter by medium), HackerRank, or Airbnb-specific mocks 
on Glassdoor. 
### Case Study Preparation 
The case study will assess your high-level approach to measuring product development and 
solving metrics problems. Expect scenarios like evaluating a new feature's impact or optimizing 
marketing spend. Structure your responses using a framework like: 
1. **Clarify the Problem**: Ask questions to define scope (e.g., "What are the success 
criteria?"). 
2. **Define Key Metrics**: North Star (e.g., bookings), proxies (e.g., engagement), guards (e.g., 
churn). 
3. **Analytical Approach**: Data sources, methods (A/B tests, causal inference), tools (SQL for 
querying, Python/R for modeling). 
4. **Dig Deeper**: Segment analysis, potential biases, next steps. 
5. **Recommendations**: Actionable insights, risks. 
#### Sample Case Studies 
Practice these with timed responses (20-30 mins), then discuss trade-offs. 
1. **Measuring a New Feature**: "Airbnb launches a 'personalized recommendations' feature 
for guests. How would you measure its success?" - Approach: North Star: Increase in booking conversion rate. Proxies: Click-through rate on 
recs, session time. Guards: No drop in host satisfaction. Method: A/B test (randomize users), 
SQL to query pre/post data, causal inference if rollout isn't clean (e.g., 
difference-in-differences). Dig deeper: Segment by user type (new vs. repeat), check for 
novelty effects. Recommendation: If uplift >5%, scale; else, iterate on algo. 
2. **Marketing Campaign Analysis**: "Evaluate the ROI of a email campaign targeting inactive 
hosts to relist properties." - Approach: Metrics: Incremental listings/reactivations, revenue lift, cost per acquisition. 
Approach: Control group (non-exposed hosts), propensity score matching for causal impact. 
SQL: Join campaigns and listings tables, aggregate reactivations post-exposure. Dig deeper: 
Cohort analysis by host tenure, attribution (first-touch vs. multi-touch). Recommendation: 
Calculate ROI as (incremental revenue - campaign cost) / cost; optimize by segmenting 
high-value hosts. 
3. **Product Metrics Problem**: "Bookings are down 10% YoY. How do you diagnose and 
propose fixes?" - Approach: Funnel breakdown: Traffic > Searches > Views > Bookings. Metrics: Drop-off 
rates at each stage. Approach: SQL cohort analysis, window functions for trends. Dig deeper: 
External factors (seasonality, competition via web data), internal (feature changes). 
Recommendation: If issue is in search-to-view, A/B test UI improvements; prioritize based on 
impact size. 
Tips for Case Study: - Tie to Airbnb's marketplace: Balance guest/host sides, consider network effects. - Mention advanced methods from JD: Causal inference (e.g., for non-random experiments), 
statistical modeling. - Practice with real data: Use public datasets like Inside Airbnb for mock analysis. 
### General Interview Tips - **Behavioral/Management**: Prepare stories on leading teams (e.g., developing analysts, 
handling conflicts), stakeholder influence, and driving impact (STAR method: Situation, Task, 
Action, Result). - **Airbnb-Specific**: Research recent news (e.g., AI integrations, post-pandemic recovery). 
Know core values: Champion the mission, be a host. - **Mock Interviews**: Use Pramp or Interviewing.io for practice. Record yourself for clarity. - **Tools/Resources**:  - Books: "Lean Analytics" for metrics, "SQL for Data Analysis" by Cathy Tanimura. 
- Online: Coursera's Google Data Analytics, Airbnb's Data University blog posts. - Search for experiences: Look up "Airbnb analytics interview" on Reddit/Glassdoor for 
patterns. - **Mindset**: Stay calm, think aloud, ask clarifying questions. Since it's senior, emphasize 
strategy over tactical execution. 
This should give you a strong foundation—focus on 2-3 hours daily on SQL practice and case 
walkthroughs. If you share more details (e.g., your background), I can refine this further! 


# SQL Query Patterns: A Framework for Data Extraction

I'll walk you through the major SQL query patterns and when to use each one based on the type of question you're trying to answer.

## 1. Basic SELECT Queries

**When to use:** When you need simple filtering and sorting of data from a single table.

```sql
SELECT first_name, last_name, hire_date
FROM employees
WHERE department_id = 10
ORDER BY hire_date DESC;
```

This is your foundation - use when questions are focused on a single entity ("Show me all sales from last month").

## 2. JOIN Operations

**When to use:** When your question involves relationships between multiple entities.

```sql
SELECT c.customer_name, o.order_date, p.product_name, oi.quantity
FROM customers c
JOIN orders o ON c.customer_id = o.customer_id
JOIN order_items oi ON o.order_id = oi.order_id
JOIN products p ON oi.product_id = p.product_id
WHERE o.order_date > '2023-01-01';
```

Use when questions involve relationships: "Which customers purchased which products?" The type of join depends on the inclusivity needed:
- INNER JOIN: Only matching records
- LEFT/RIGHT JOIN: All records from one table, matching from another
- FULL JOIN: All records from both tables

## 3. Aggregation Queries

**When to use:** When you need to summarize data or answer "how many," "what's the average," etc.

```sql
SELECT 
    department_id,
    COUNT(*) AS employee_count,
    AVG(salary) AS avg_salary,
    MIN(hire_date) AS earliest_hire
FROM employees
GROUP BY department_id
HAVING COUNT(*) > 5
ORDER BY avg_salary DESC;
```

Useful for questions about totals, averages, minimums, maximums, or counts within groups.

## 4. Subqueries

**When to use:** When one query depends on the results of another query.

```sql
SELECT employee_id, first_name, last_name
FROM employees
WHERE salary > (
    SELECT AVG(salary) 
    FROM employees
);
```

Good for questions like "Find employees who earn above the average salary" or "Which products have sold more than the company average?"

## 5. Common Table Expressions (CTEs)

**When to use:** When you need to break a complex query into logical steps or when a subquery would be used multiple times.

```sql
WITH monthly_sales AS (
    SELECT 
        DATE_TRUNC('month', order_date) AS month,
        SUM(amount) AS total_sales
    FROM orders
    GROUP BY DATE_TRUNC('month', order_date)
),
avg_monthly AS (
    SELECT AVG(total_sales) AS avg_monthly_sales
    FROM monthly_sales
)
SELECT 
    month,
    total_sales,
    total_sales - avg_monthly_sales AS sales_difference
FROM monthly_sales, avg_monthly
ORDER BY month;
```

Excellent for multi-step analysis: "Compare each month's sales to the overall monthly average." CTEs make queries more readable than nested subqueries.

## 6. Window Functions

**When to use:** When you need to perform calculations across rows while still maintaining row identity.

```sql
SELECT 
    employee_id,
    department_id,
    salary,
    AVG(salary) OVER(PARTITION BY department_id) AS dept_avg,
    salary - AVG(salary) OVER(PARTITION BY department_id) AS diff_from_avg,
    RANK() OVER(PARTITION BY department_id ORDER BY salary DESC) AS salary_rank
FROM employees;
```

Perfect for questions involving:
- Rankings: "What's each product's sales rank within its category?"
- Running totals: "What are the cumulative sales by day?"
- Comparisons: "How does each employee's salary compare to their department average?"

## 7. Set Operations

**When to use:** When you need to combine or compare results from multiple queries.

```sql
-- Customers who purchased Product A but not Product B
SELECT customer_id
FROM orders
JOIN order_items ON orders.order_id = order_items.order_id
WHERE product_id = 'A'
EXCEPT
SELECT customer_id
FROM orders
JOIN order_items ON orders.order_id = order_items.order_id
WHERE product_id = 'B';
```

Useful for:
- UNION: Combining results (with UNION ALL for duplicates)
- INTERSECT: Finding common results
- EXCEPT: Finding differences between results

## 8. Conditional Logic

**When to use:** When you need to apply different logic based on conditions.

```sql
SELECT 
    order_id,
    amount,
    CASE 
        WHEN amount < 100 THEN 'Small'
        WHEN amount BETWEEN 100 AND 1000 THEN 'Medium'
        ELSE 'Large'
    END AS order_size
FROM orders;
```

Great for:
- Categorization: "Label orders as small, medium, or large"
- Conditional aggregation: "Count orders by size category"

## 9. Recursive CTEs

**When to use:** When dealing with hierarchical data or graph relationships.

```sql
WITH RECURSIVE org_hierarchy AS (
    -- Base case: CEO (no manager)
    SELECT employee_id, name, manager_id, 1 AS level
    FROM employees
    WHERE manager_id IS NULL
    
    UNION ALL
    
    -- Recursive case: get all direct reports
    SELECT e.employee_id, e.name, e.manager_id, h.level + 1
    FROM employees e
    JOIN org_hierarchy h ON e.manager_id = h.employee_id
)
SELECT * FROM org_hierarchy ORDER BY level, employee_id;
```

Essential for:
- Organizational hierarchies: "Show me all reports up to 3 levels deep"
- Bill of materials: "List all components needed for a product"
- Path finding: "Find all possible routes between cities"

## Decision Framework

When approaching a data question, consider this sequence:

1. **Identify the entities involved**
   - Single entity → Basic SELECT
   - Multiple related entities → JOINs

2. **Determine the calculation type**
   - Summarization across groups → GROUP BY aggregation
   - Row-by-row calculations with access to other rows → Window functions
   - Conditional results → CASE statements

3. **Consider the query complexity**
   - Query needs multiple logical steps → CTEs
   - Query requires a result from another query → Subquery
   - Hierarchical relationships → Recursive CTE
   - Set-based operations → UNION/INTERSECT/EXCEPT

4. **Optimize for readability**
   - Repeated subqueries → CTEs
   - Deeply nested logic → Break into multiple CTEs

## Practical Examples by Question Type

### Question: "What is the sales trend by month?"
```sql
SELECT 
    DATE_TRUNC('month', order_date) AS month,
    SUM(amount) AS monthly_sales
FROM orders
GROUP BY DATE_TRUNC('month', order_date)
ORDER BY month;
```

### Question: "Which customers increased their spending each month?"
```sql
WITH monthly_spend AS (
    SELECT 
        customer_id,
        DATE_TRUNC('month', order_date) AS month,
        SUM(amount) AS total_spend
    FROM orders
    GROUP BY customer_id, DATE_TRUNC('month', order_date)
)
SELECT 
    customer_id,
    month,
    total_spend,
    LAG(total_spend) OVER(PARTITION BY customer_id ORDER BY month) AS prev_month_spend,
    CASE 
        WHEN total_spend > LAG(total_spend) OVER(PARTITION BY customer_id ORDER BY month) THEN 'Increased'
        ELSE 'Decreased or Same'
    END AS spend_trend
FROM monthly_spend
ORDER BY customer_id, month;
```

### Question: "What's the market share of each product category by quarter?"
```sql
WITH quarterly_sales AS (
    SELECT 
        DATE_TRUNC('quarter', o.order_date) AS quarter,
        p.category,
        SUM(oi.quantity * oi.unit_price) AS category_sales
    FROM orders o
    JOIN order_items oi ON o.order_id = oi.order_id
    JOIN products p ON oi.product_id = p.product_id
    GROUP BY DATE_TRUNC('quarter', o.order_date), p.category
),
total_quarterly AS (
    SELECT 
        quarter,
        SUM(category_sales) AS total_sales
    FROM quarterly_sales
    GROUP BY quarter
)
SELECT 
    qs.quarter,
    qs.category,
    qs.category_sales,
    tq.total_sales,
    ROUND((qs.category_sales / tq.total_sales) * 100, 2) AS market_share
FROM quarterly_sales qs
JOIN total_quarterly tq ON qs.quarter = tq.quarter
ORDER BY qs.quarter, market_share DESC;
```

By understanding these patterns and when to apply them, you'll be able to tackle most data extraction challenges efficiently and effectively.


# The Best Medium-Hard Data Analyst SQL Interview Questions  

By Zachary Thomas ([zthomas.nc@gmail.com](mailto:zthomas.nc@gmail.com), [Twitter](https://twitter.com/zach_i_thomas), [LinkedIn](https://www.linkedin.com/in/thomaszi/)) 

**Tip: **See the Table of Contents (document outline) by hovering over the vertical line on the right side of the page 

## Background & Motivation

> The first 70% of SQL is pretty straightforward but the remaining 30% can be pretty tricky.


Between the fall of 2015 and the summer of 2019 I interviewed for data analyst and data scientists positions four separate times, getting to onsite interviews at over a dozen companies. After an interview in 2017 went poorly — mostly due to me floundering at the more difficult SQL questions they asked me — I started putting together a study guide of medium and hard SQL questions to better prepare and found it particularly useful during my 2019 interview cycle. Over the past year I have shared that guide with a couple of friends, and with the extra time on my hands due to the coronavirus pandemic, I have polished it up into this doc. 

There are plenty of great beginner SQL guides out there. My favorites are Codecademy’s [interactive SQL courses](https://www.codecademy.com/learn/learn-sql) and Zi Chong Kao’s [Select Star SQL](https://selectstarsql.com/). However, like I told a friend, while the first 70% of SQL is pretty straightforward, the remaining 30% can be pretty tricky. Data analyst and data scientist interview questions at technology companies often pull from that 30%.  

Strangely, I have never really found a comprehensive source online for those medium-hard SQL questions, which is why I put together this guide. 

Working through this guide should improve your performance on data analyst interviews. It should also make you better at your current and future job positions. Personally, I find some of the SQL patterns found in this doc useful for ETLs powering reporting tools featuring trends over time. 

To be clear, data analyst and data scientist interviews consist of more than SQL questions. Other common topics include explaining past projects, A/B testing, metric development and open-ended analytical problems. This [Quora answer](https://qr.ae/pNrdGV) has Facebook’s product analyst interview guide circa 2017, which discusses this topic in more depth. That said, if improving your SQL skills can make your interviews less stressful than they already are, it could very well be worth your time. 

In the future, I may transition this doc to a website like [Select Star SQL](https://selectstarsql.com/) with an embedded SQL editor so that readers can write SQL statements to questions and get real-time feedback on their code. Another option could be adding these questions as problems on Leetcode. For the time being though I just wanted to publish this doc so that people could find it useful now.  

**I would love to get your feedback on this doc. Please drop a note if you find this useful, have improvements/corrections, or encounter other good resources for medium/hard difficulty SQL questions. **

## Assumptions & How to use this guide 

**Assumptions about SQL proficiency: **This guide assumes you have a working knowledge of SQL. You probably use it frequently at work already but want to sharpen your skills on topics like self-joins and window functions. 

**How to use this guide:** Since interviews usually utilize a whiteboard or a virtual (non-compiling) notepad, my recommendation is to get out a pencil and paper and write out your solutions to each part of the problem, and once complete compare your answers to the answer key. Or, complete these with a friend who can act as the interviewer!

* Small SQL syntax errors aren’t a big deal during whiteboard/notepad interviews. However, they can distracting to the interviewer, so ideally practice reducing these so your logic shines through in the interview. 
* The answers I provide may not be the only way to successfully solve the question. Feel free to message with additional solutions and I can add them to this guide! 

## Tips on solving difficult SQL interview questions 

This advice mirrors typical code interview advice ... 

1. Listen carefully to problem description, repeat back the crux of the problem to the interviewer
2. Spell out an edge case to demonstrate you actually understand problem (i.e. a row that *wouldn’t* be included in the output of the SQL you are about to sketch out) 
3. (If the problem involves a self-join) For your own benefit sketch out what the self-join will look like — this will typically be at least three columns: a column of interest from the main table, the column to join from the main table, and the column to join from the secondary table 
    1. Or, as you get more used to self-join problems, you can explain this step verbally 
4. Start writing SQL — err towards writing SQL versus trying to perfectly understand the problem. Verbalize your assumptions as you go so your interviewer can correct you if you go astray. 

## Acknowledgments and Additional Resources 

Some of the problems listed here are adapted from old Periscope blog posts (mostly written around 2014 by [Sean Cook](https://www.linkedin.com/in/seangcook/), although his authorship seems to have been removed from the posts following SiSense's [merger with](https://www.sisense.com/blog/sisense-and-periscope-data-merge-2/) Periscope) or discussions from Stack Overflow; I've noted them at the start of questions as appropriate. 

[Select Star SQL](https://selectstarsql.com/) has good[challenge questions](https://selectstarsql.com/questions.html#challenge_questions) that are complementary to the questions in this doc. 

Please note that these questions are not literal copies of SQL interview questions I have encountered while interviewing nor were they interview questions used at a company I have worked at or work at. 
* * *

# Self-Join Practice Problems 

## #1: MoM Percent Change 

**Context:** Oftentimes it's useful to know how much a key metric, such as monthly active users, changes between months. Say we have a table `logins` in the form: 

```
| user_id | date       |
|---------|------------|
| 1       | 2018-07-01 |
| 234     | 2018-07-02 |
| 3       | 2018-07-02 |
| 1       | 2018-07-02 |
| ...     | ...        |
| 234     | 2018-10-04 |
```

**Task**: Find the month-over-month percentage change for monthly active users (MAU). 
* * *
***Solution:***

*(This solution, like other solution code blocks you will see in this doc, contains comments about SQL syntax that may differ between flavors of SQL or other comments about the solutions as listed) *

```
WITH mau AS 
(
  SELECT 
   /* 
    * Typically, interviewers allow you to write psuedocode for date functions 
    * i.e. will NOT be checking if you have memorized date functions. 
    * Just explain what your function does as you whiteboard 
    *
    * DATE_TRUNC() is available in Postgres, but other SQL date functions or 
    * combinations of date functions can give you a identical results   
    * See https://www.postgresql.org/docs/9.0/functions-datetime.html#FUNCTIONS-DATETIME-TRUNC
    */ 
    DATE_TRUNC('month', date) month_timestamp,
    COUNT(DISTINCT user_id) mau
  FROM 
    logins 
  GROUP BY 
    DATE_TRUNC('month', date)
  )
 
 SELECT 
    /*
    * You don't literally need to include the previous month in this SELECT statement. 
    * 
    * However, as mentioned in the "Tips" section of this guide, it can be helpful 
    * to at least sketch out self-joins to avoid getting confused which table 
    * represents the prior month vs current month, etc. 
    */ 
    a.month_timestamp previous_month, 
    a.mau previous_mau, 
    b.month_timestamp current_month, 
    b.mau current_mau, 
    ROUND(100.0*(b.mau - a.mau)/a.mau,2) AS percent_change 
 FROM
    mau a 
 JOIN 
    /*
    * Could also have done `ON b.month_timestamp = a.month_timestamp + interval '1 month'` 
    */
    mau b ON a.month_timestamp = b.month_timestamp - interval '1 month' 
  
```



## #2: Tree Structure Labeling   

**Context:** Say you have a table `tree` with a column of nodes and a column corresponding parent nodes 

```
node   parent
1       2
2       5
3       5
4       3
5       NULL 
```

**Task:** Write SQL such that we label each node as a “leaf”, “inner” or “Root” node, such that for the nodes above we get: 

```
node    label  
1       Leaf
2       Inner
3       Inner
4       Leaf
5       Root
```

(Side note: [this link](http://ceadserv1.nku.edu/longa//classes/mat385_resources/docs/trees.html) has more details on Tree data structure terminology. Not needed to solve the problem though!)
* * *
***Solution:***

**Acknowledgement:** this more generalizable solution was contributed by Fabian Hofmann on 5/2/20. Thank, FH! 

```
WITH join_table AS
(
    SELECT 
        cur.node, 
        cur.parent, 
        COUNT(next.node) AS num_children
    FROM 
        tree cur
    LEFT JOIN 
        tree next ON (next.parent = cur.node)
    GROUP BY 
        cur.node, 
        cur.parent
)

SELECT
    node,
    CASE
        WHEN parent IS NULL THEN "Root"
        WHEN num_children = 0 THEN "Leaf"
        ELSE "Inner"
    END AS label
FROM 
    join_table 
```

An alternate solution, without explicit joins: 

```
SELECT 
    node,
    CASE 
        WHEN parent IS NULL THEN 'Root'
        WHEN node NOT IN (SELECT parent FROM tree) THEN 'Leaf'
        WHEN node IN (SELECT parent FROM tree) AND parent IS NOT NULL THEN 'Inner'
    END AS label 
 from 
    tree
```



## #3: Retained Users Per Month (multi-part)

**Acknowledgement: **this problem is adapted from SiSense’s [“Using Self Joins to Calculate Your Retention, Churn, and Reactivation Metrics”](https://www.sisense.com/blog/use-self-joins-to-calculate-your-retention-churn-and-reactivation-metrics/) blog post

### Part 1: 

**Context:** Say we have login data in the table `logins`: 

```
| user_id | date       |
|---------|------------|
| 1       | 2018-07-01 |
| 234     | 2018-07-02 |
| 3       | 2018-07-02 |
| 1       | 2018-07-02 |
| ...     | ...        |
| 234     | 2018-10-04 |
```

**Task:** Write a query that gets the number of retained users per month. In this case, retention for a given month is defined as the number of users who logged in that month who also logged in the immediately previous month. 
* * *
***Solution:***

```
SELECT 
    DATE_TRUNC('month', a.date) month_timestamp, 
    COUNT(DISTINCT a.user_id) retained_users 
 FROM 
    logins a 
 JOIN 
    logins b ON a.user_id = b.user_id 
        AND DATE_TRUNC('month', a.date) = DATE_TRUNC('month', b.date) + 
                                             interval '1 month'
 GROUP BY 
    date_trunc('month', a.date)
```



### Part 2: 

**Task:** Now we’ll take retention and turn it on its head: Write a query to find many users last month *did not* come back this month. i.e. the number of churned users.  
* * *
***Solution:***

```
SELECT 
    DATE_TRUNC('month', a.date) month_timestamp, 
    COUNT(DISTINCT b.user_id) churned_users 
FROM 
    logins a 
FULL OUTER JOIN 
    logins b ON a.user_id = b.user_id 
        AND DATE_TRUNC('month', a.date) = DATE_TRUNC('month', b.date) + 
                                         interval '1 month'
WHERE 
    a.user_id IS NULL 
GROUP BY 
    DATE_TRUNC('month', a.date)
```

Note that there are solutions to this problem that can use `LEFT` or `RIGHT` joins. 


### Part 3: 

**Note:** this question is probably more complex than the kind you would encounter in an interview. Consider it a challenge problem, or feel free to skip it!

**Context**: Good work on the previous two problems! Data engineering has decided to give you a helping hand by creating a table of churned users per month, `user_churns`. If a user is active last month but then not active this month, then that user gets an entry for this month. `user_churns` has the form: 

```
| user_id | month_date |
|---------|------------|
| 1       | 2018-05-01 |
| 234     | 2018-05-01 |
| 3       | 2018-05-01 |
| 12      | 2018-05-01 |
| ...     | ...        |
| 234     | 2018-10-01 |
```


**Task**: You now want to do a cohort analysis of active users this month *who have been reactivated users in the past*. Create a table that contains these users. You may use the tables `user_churns` as well as `logins` to create this cohort. In Postgres, the current timestamp is available through `current_timestamp`.
* * *
***Solution:***

```
WITH user_login_data AS 
(
    SELECT 
        DATE_TRUNC('month', a.date) month_timestamp,
        a.user_id,
        /* 
        * At least in the flavors of SQL I have used, you don't need to 
        * include the columns used in HAVING in the SELECT statement.
        * I have written them out for clarity here.  
        */ 
        MAX(b.month_date) as most_recent_churn, 
        MAX(DATE_TRUNC('month', c.date)) as most_recent_active 
     FROM 
        logins a
     JOIN 
        user_churns b 
            ON a.user_id = b.user_id AND DATE_TRUNC('month', a.date) > b.month_date 
     JOIN
        logins c 
            ON a.user_id = c.user_id 
            AND 
            DATE_TRUNC('month', a.date) > DATE_TRUNC('month', c.date)
     WHERE 
        DATE_TRUNC('month', a.date) = DATE_TRUNC('month', current_timestamp)
     GROUP BY 
        DATE_TRUNC('month', a.date),
        a.user_id
     HAVING 
        most_recent_churn > most_recent_active
```



## #4: Cumulative Sums 

**Acknowledgement:** This problem was inspired by Sisense’s[“Cash Flow modeling in SQL”](https://www.sisense.com/blog/cash-flow-modeling-in-sql/) blog post 

**Context:** Say we have a table `transactions` in the form:

```
| date       | cash_flow |
|------------|-----------|
| 2018-01-01 | -1000     |
| 2018-01-02 | -100      |
| 2018-01-03 | 50        |
| ...        | ...       |
```

Where `cash_flow` is the revenues minus costs for each day. 

**Task: **Write a query to get *cumulative* cash flow for each day such that we end up with a table in the form below: 

```
| date       | cumulative_cf |
|------------|---------------|
| 2018-01-01 | -1000         |
| 2018-01-02 | -1100         |
| 2018-01-03 | -1050         |
| ...        | ...           |
```

* * *
***Solution:***

```
SELECT 
    a.date date, 
    SUM(b.cash_flow) as cumulative_cf 
FROM
    transactions a
JOIN b 
    transactions b ON a.date >= b.date 
GROUP BY 
    a.date 
ORDER BY 
    date ASC
```

Alternate solution using a window function (more efficient!):  

```
SELECT 
    date, 
    SUM(cash_flow) OVER (ORDER BY date ASC) as cumulative_cf 
FROM
    transactions 
ORDER BY 
    date ASC
```

## #5: Rolling Averages 

**Acknowledgement:** This problem is adapted from Sisense’s [“Rolling Averages in MySQL and SQL Server”](https://www.sisense.com/blog/rolling-average/) blog post 

**Note:** there are different ways to compute rolling/moving averages. Here we'll use a preceding average which means that the metric for the 7th day of the month would be the average of the preceding 6 days and that day itself. 

**Context**: Say we have table `signups` in the form: 

```
| date       | sign_ups |
|------------|----------|
| 2018-01-01 | 10       |
| 2018-01-02 | 20       |
| 2018-01-03 | 50       |
| ...        | ...      |
| 2018-10-01 | 35       |
```

**Task**: Write a query to get 7-day rolling (preceding) average of daily sign ups. 
* * *
***Solution:***

```
SELECT 
  a.date, 
  AVG(b.sign_ups) average_sign_ups 
FROM 
  signups a 
JOIN 
  signups b ON a.date <= b.date + interval '6 days' AND a.date >= b.date
GROUP BY 
  a.date
```



## #6: Multiple Join Conditions 

**Acknowledgement:** This problem was inspired by Sisense’s [“Analyzing Your Email with SQL”](https://www.sisense.com/blog/analyzing-your-email-with-sql/) blog post 

**Context:** Say we have a table `emails` that includes emails sent to and from [`zach@g.com`](mailto:zach@g.com):

```
| id | subject  | from         | to           | timestamp           |
|----|----------|--------------|--------------|---------------------|
| 1  | Yosemite | zach@g.com   | thomas@g.com | 2018-01-02 12:45:03 |
| 2  | Big Sur  | sarah@g.com  | thomas@g.com | 2018-01-02 16:30:01 |
| 3  | Yosemite | thomas@g.com | zach@g.com   | 2018-01-02 16:35:04 |
| 4  | Running  | jill@g.com   | zach@g.com   | 2018-01-03 08:12:45 |
| 5  | Yosemite | zach@g.com   | thomas@g.com | 2018-01-03 14:02:01 |
| 6  | Yosemite | thomas@g.com | zach@g.com   | 2018-01-03 15:01:05 |
| .. | ..       | ..           | ..           | ..                  |
```

**Task: **Write a query to get the response time per email (`id`) sent to `zach@g.com` . Do not include `id`s that did not receive a response from [zach@g.com](mailto:zach@g.com). Assume each email thread has a unique subject. Keep in mind a thread may have multiple responses back-and-forth between [zach@g.com](mailto:zach@g.com) and another email address. 
* * *
***Solution:***

```
SELECT 
    a.id, 
    MIN(b.timestamp) - a.timestamp as time_to_respond 
FROM 
    emails a 
JOIN
    emails b 
        ON 
            b.subject = a.subject 
        AND 
            a.to = b.from
        AND 
            a.from = b.to 
        AND 
            a.timestamp < b.timestamp 
 WHERE 
    a.to = 'zach@g.com' 
 GROUP BY 
    a.id 
```



# Window Function Practice Problems 

## #1: Get the ID with the highest value 

**Context:** Say we have a table `salaries` with data on employee salary and department in the following format: 

```
  depname  | empno | salary |     
-----------+-------+--------+
 develop   |    11 |   5200 | 
 develop   |     7 |   4200 | 
 develop   |     9 |   4500 | 
 develop   |     8 |   6000 | 
 develop   |    10 |   5200 | 
 personnel |     5 |   3500 | 
 personnel |     2 |   3900 | 
 sales     |     3 |   4800 | 
 sales     |     1 |   5000 | 
 sales     |     4 |   4800 | 
```

**Task**: Write a query to get the `empno` with the highest salary. Make sure your solution can handle ties!
* * *
***Solution:***

```
WITH max_salary AS (
    SELECT 
        MAX(salary) max_salary
    FROM 
        `salaries
    )
SELECT 
    s.empno
FROM 
    `salaries s
JOIN 
    max_salary ms ON s.salary = ms.max_salary ``
```

Alternate solution using `RANK()`:

```
WITH sal_rank AS 
  (SELECT 
    empno, 
    RANK() OVER(ORDER BY salary DESC) rnk
  FROM 
    salaries)
SELECT 
  empno
FROM
  sal_rank
WHERE 
  rnk = 1;
```



## #2: Average and rank with a window function (multi-part)

### Part 1: 

**Context**: Say we have a table `salaries` in the format:

```
  depname  | empno | salary |     
-----------+-------+--------+
 develop   |    11 |   5200 | 
 develop   |     7 |   4200 | 
 develop   |     9 |   4500 | 
 develop   |     8 |   6000 | 
 develop   |    10 |   5200 | 
 personnel |     5 |   3500 | 
 personnel |     2 |   3900 | 
 sales     |     3 |   4800 | 
 sales     |     1 |   5000 | 
 sales     |     4 |   4800 | 
```

**Task:** Write a query that returns the same table, but with a new column that has average salary per `depname`. We would expect a table in the form: 

```
  depname  | empno | salary | avg_salary |     
-----------+-------+--------+------------+
 develop   |    11 |   5200 |       5020 |
 develop   |     7 |   4200 |       5020 | 
 develop   |     9 |   4500 |       5020 |
 develop   |     8 |   6000 |       5020 | 
 develop   |    10 |   5200 |       5020 | 
 personnel |     5 |   3500 |       3700 |
 personnel |     2 |   3900 |       3700 |
 sales     |     3 |   4800 |       4867 | 
 sales     |     1 |   5000 |       4867 | 
 sales     |     4 |   4800 |       4867 |
```

* * *
***Solution:***

```
SELECT 
    *, 
    /*
    * AVG() is a Postgres command, but other SQL flavors like BigQuery use 
    * AVERAGE()
    */ 
    ROUND(AVG(salary),0) OVER (PARTITION BY depname) avg_salary
FROM
    salaries
```

### Part 2:

**Task:** Write a query that adds a column with the rank of each employee based on their salary within their department, where the employee with the highest salary gets the rank of `1`. We would expect a table in the form: 

```
  depname  | empno | salary | salary_rank |     
-----------+-------+--------+-------------+
 develop   |    11 |   5200 |           2 |
 develop   |     7 |   4200 |           5 | 
 develop   |     9 |   4500 |           4 |
 develop   |     8 |   6000 |           1 | 
 develop   |    10 |   5200 |           2 | 
 personnel |     5 |   3500 |           2 |
 personnel |     2 |   3900 |           1 |
 sales     |     3 |   4800 |           2 | 
 sales     |     1 |   5000 |           1 | 
 sales     |     4 |   4800 |           2 | 
```

* * *
***Solution:***

```
SELECT 
    *, 
    RANK() OVER(PARTITION BY depname ORDER BY salary DESC) salary_rank
 FROM  
    salaries 
```



# Other Medium/Hard SQL Practice Problems 

## #1: Histograms 

**Context:** Say we have a table `sessions` where each row is a video streaming session with length in seconds: 

```
| session_id | length_seconds |
|------------|----------------|
| 1          | 23             |
| 2          | 453            |
| 3          | 27             |
| ..         | ..             |
```

**Task:** Write a query to count the number of sessions that fall into bands of size 5, i.e. for the above snippet, produce something akin to: 

```
| bucket  | count |
|---------|-------|
| 20-25   | 2     |
| 450-455 | 1     |
```

Get complete credit for the proper string labels (“5-10”, etc.) but near complete credit for something that is communicable as the bin. 
* * *
***Solution:***

```
WITH bin_label AS 
(SELECT 
    session_id, 
    FLOOR(length_seconds/5) as bin_label 
 FROM
    sessions 
 )
 SELECT 
    `CONCATENTATE(STR(bin_label*5), '-', STR(`bin_label*5+5)) bucket, 
    COUNT(DISTINCT session_id) count ``
 GROUP BY 
    bin_label
 ORDER BY 
    `bin_label ASC `
```



## #2: CROSS JOIN (multi-part)

### Part 1: 

**Context:** Say we have a table `state_streams` where each row is a state and the total number of hours of streaming from a video hosting service: 

```
| state | total_streams |
|-------|---------------|
| NC    | 34569         |
| SC    | 33999         |
| CA    | 98324         |
| MA    | 19345         |
| ..    | ..            |
```

(In reality these kinds of aggregate tables would normally have a date column, but we’ll exclude that component in this problem) 

**Task:** Write a query to get the pairs of states with total streaming amounts within 1000 of each other. For the snippet above, we would want to see something like:

```
| state_a | state_b |
|---------|---------|
| NC      | SC      |
| SC      | NC      |
```

* * *
***Solution:***

```
SELECT
    a.state as state_a, 
    b.state as state_b 
 FROM   
    state_streams a
 CROSS JOIN 
    state_streams b 
 WHERE 
    ABS(a.total_streams - b.total_streams) < 1000
    AND 
    a.state <> b.state 
```

FYI, `CROSS JOIN` s can also be written without explicitly specifying a join: 

```
SELECT
    a.state as state_a, 
    b.state as state_b 
 FROM   
    state_streams a, state_streams b 
 WHERE 
    ABS(a.total_streams - b.total_streams) < 1000
    AND 
    a.state <> b.state 
```



### Part 2: 

**Note:** This question is considered more of a bonus problem than an actual SQL pattern. Feel free to skip it!

**Task:** How could you modify the SQL from the solution to Part 1 of this question so that duplicates are removed? For example, if we used the sample table from Part 1, the pair `NC` and `SC` should only appear in one row instead of two. 
* * *
***Solution: ***

```
SELECT
    a.state as state_a, 
    b.state as state_b 
 FROM   
    state_streams a, state_streams b 
 WHERE 
    ABS(a.total_streams - b.total_streams) < 1000
    AND 
    a.state > b.state 
```



## #3: Advancing Counting 

**Acknowledgement:** This question is adapted from [this Stack Overflow question](https://stackoverflow.com/questions/54488894/using-case-to-properly-count-items-with-if-else-logic-in-sql) by me (zthomas.nc) 

**Note:** this question is probably more complex than the kind you would encounter in an interview. Consider it a challenge problem, or feel free to skip it! 

**Context: **Say I have a table `table` in the following form, where a `user` can be mapped to multiple values of `class`:

```
| user | class |
|------|-------|
| 1    | a     |
| 1    | b     |
| 1    | b     |
| 2    | b     |
| 3    | a     |
```

**Task:** Assume there are only two possible values for `class`. Write a query to count the number of users in each class such that any user who has label `a` and `b` gets sorted into `b`, any user with just `a` gets sorted into `a` and any user with just `b` gets into `b`. 

For `table` that would result in the following table: 

```
| class | count |
|-------|-------|
| a     | 1     |
 | b     | 2     |
```

* * *
***Solution: ***

```
WITH usr_b_sum AS 
(
    SELECT 
        user, 
        SUM(CASE WHEN class = 'b' THEN 1 ELSE 0 END) num_b
    FROM 
        table
    GROUP BY 
        user
), 

usr_class_label AS 
(
    SELECT 
        user, 
        CASE WHEN num_b > 0 THEN 'b' ELSE 'a' END class 
    FROM 
        usr_b_sum
)

SELECT 
    class, 
    COUNT(DISTINCT user) count 
FROM
    usr_class_label
GROUP BY 
    class 
ORDER BY 
    class ASC

    
```

Alternate solution: Using `SELECT`s in the `SELECT` statement and `UNION`: 

```
SELECT 
    "a" class,
    COUNT(DISTINCT user_id) - 
        (SELECT COUNT(DISTINCT user_id) FROM table WHERE class = 'b') count 
UNION
SELECT 
    "b" class,
    (SELECT COUNT(DISTINCT user_id) FROM table WHERE class = 'b') count 
```


Coding / Technical (SQL & Python) Questions
Meta’s technical screens focus heavily on SQL and Python, with recent Meta data scientist interview questions 2024 centering around data wrangling, simulation, and optimization problems, similar to what you’d find in Facebook data scientist interview questions:

1. Find how much overlapping jobs are costing the company

To solve this, simulate the scenario by generating random start times for two jobs within the 300-minute window (7 pm to midnight) and check for overlaps. Repeat the simulation N times to estimate the probability of overlap, then multiply this probability by the annual cost factor (365 days * $1000 per overlap) to get the estimated annual cost.

2. Given a dictionary with weights, write a function random_key that returns a key at random with a probability proportional to the weights.

To solve this, construct a list where each key appears a number of times equal to its weight. Use Python’s random.choice() to select a key randomly from this list. This ensures the probability of selecting a key is proportional to its weight.

3. Write a query to get the average commute time for each commuter in New York

To solve this, use two subqueries: one to calculate the average commute time for each commuter in New York grouped by commuter_id, and another to calculate the average commute time across all commuters in New York. Use the TIMESTAMPDIFF function to calculate the time difference in minutes between start_dt and end_dt. Finally, perform a LEFT JOIN to combine the results of both subqueries.

4. Matrix Rotation

To rotate a matrix 90 degrees clockwise, first transpose the matrix and then reverse the order of its columns. Transposing swaps rows and columns, while reversing columns achieves the desired rotation. This approach is efficient and leverages simple matrix transformations.

5. Write a query to create a metric that can validate and rank the queries by their search result precision

To compute the precision metric, start by calculating the average rating for each query using AVG(rating) grouped by the query column. To incorporate position into the metric, use the inverse of the position as a weighted factor (1/position) multiplied by the rating. This ensures higher weights for top positions.

6. Write a Python function called max_profit to calculate the maximum profit with at most two buy/sell transactions

To solve this, iterate through the list of prices while maintaining four variables: buy1, profit1, buy2, and profit2. buy1 tracks the lowest price for the first transaction, and profit1 calculates the profit from the first transaction. buy2 adjusts for the profit from the first transaction, and profit2 calculates the maximum profit from two transactions. Return profit2 as the result.

Product & Experimentation / A/B Test Questions
A core part of the Meta data scientist product analytics interview involves product-sense and experimentation challenges that test your ability to define metrics, evaluate tests, and think like a product partner in a data-driven organization:

7. How would you assess the validity of the result in an AB test?

To assess the validity of the result, first ensure that the user groups were properly separated and randomly bucketed to avoid biases. Next, confirm that the variants were equal in all other aspects except the tested feature. Additionally, evaluate the measurement process, including sample size, duration of the test, and whether the p-value was monitored continuously, as this can lead to false positives or negatives. Finally, determine the minimum effect size and compute the required sample size and duration before starting the experiment to ensure statistical reliability.

8. Revenue Retention: Calculate the formula for the average lifetime value

To calculate the average lifetime value (LTV) for a subscription-based service, use the formula (LTV = \sum_{i=0}^{\infty} 100 \cdot 0.9^i), where 100 is the monthly subscription cost and 0.9 represents the retention rate after accounting for 10% churn. This formula sums the expected value of the customer over infinite months, converging to (LTV = $1000). The calculation accounts for retention rates and churn, providing a more accurate LTV than simply multiplying the average customer duration by the monthly cost.

9. Given a list of strings, write a function that returns the longest common prefix

To measure the percentage of fake news stories within 24 hours, start by defining what constitutes fake news, such as spam, bot-generated content, or incorrect media reporting. Then, use unsupervised methods to identify fake accounts, analyze article sharing patterns, and validate media outlets’ credibility. Metrics like user engagement, account authenticity, and cross-referencing news titles can help infer the percentage of fake news stories.

10. Given a team wants to A/B test multiple changes through a sign-up funnel, how would you set up this test?

To set up this test, you would create a multivariate test with four variants: red button at the top, red button at the bottom, blue button at the top, and blue button at the bottom. Randomly assign users to each variant and calculate the sample size needed to reach statistical significance. Alternatively, chaining A/B tests could be considered, but this approach would not account for interaction effects between the variables.

11. Given customer spending data, how would you determine the next partner card?

To determine the next partner card, analyze customer transaction data by grouping spending by merchants and identifying high-spending merchants without existing partnerships. Consider metrics like average transaction price and frequency to optimize for recurring spending. Additionally, examine year-over-year growth trends to forecast future high-spending merchants and conduct external research to identify merchants popular outside the current dataset for customer acquisition.

Behavioral & Culture-Fit Questions
The data scientist Meta interview also includes behavioral prompts designed to assess collaboration, resilience, and alignment with Meta’s values—key qualities that Facebook data science interview loops look for in high-performing candidates:

12. Describe an analytics experiment that you designed. How were you able to measure success?

In a Meta context, this question is often about demonstrating your ability to design robust, scalable experiments that drive product decisions. You might describe designing an A/B test to evaluate the impact of a new ranking algorithm on user engagement within the News Feed.

Success would be measured through metrics like time spent, click-through rates, or meaningful social interactions. You should explain how you set up the control and treatment groups, ensured randomization, and accounted for bias or variance. Mention tools like Hive, PyTorch, or Meta’s internal experimentation platforms, and show how you used p-values or confidence intervals to validate findings and inform product rollout decisions.

13. Talk about a time when you had trouble communicating with stakeholders. How were you able to overcome it?

At Meta, stakeholders range from product managers to engineers and designers, and they often have different levels of technical fluency. You could describe a time when you presented a complex causal inference model, but the team found it too abstract.

To overcome this, you simplified the narrative using data visualizations and drew parallels to user behavior they were more familiar with. You might mention how you scheduled follow-ups or embedded yourself in sprint reviews to build context. Emphasize how this experience improved your stakeholder management and ultimately helped align teams on the insights and next steps.

14. Why Do You Want to Work With Us

For a Metadata Scientist role at Meta, you should go beyond generic enthusiasm. Highlight how Meta’s commitment to open science, large-scale experimentation, and infrastructure for data scientists aligns with your interests.

For example, you could mention your excitement about working on products that impact billions of users or the opportunity to contribute to innovations in content discovery, trust and safety, or generative AI. Be specific about how Meta’s scale and emphasis on measurement excellence match your goals. This is also a good place to reflect on Meta’s core values like “Focus on Long-Term Impact” or “Move Fast.”

15. Describe a data project you worked on. What were some of the challenges you faced?

This is a chance to show your ability to drive a project end-to-end. For a Meta role, you could describe working on a project where you built a machine learning model to predict user churn or optimized a recommendation pipeline.

Explain the technical scope, like data ingestion with Presto, model training using PyTorch, and how you collaborated with product teams to define success. Then describe real-world challenges—maybe you faced incomplete logging or had to backfill data to simulate historical results. Talk about how you navigated ambiguity, validated your approach with stakeholders, and iterated to ship a solution that drove measurable impact.


General SQL Interview Questions for Intermediate to Advanced Users
As you progress in your SQL journey from beginner to Intermediate level, interviewers expect more than just knowledge of basic syntax. They’re looking for hands-on experience, depth of understanding and the ability to tackle real-world database challenges. These general interview questions help assess your proficiency, problem-solving skills and ability to work with large-scale data systems.

Below are some commonly asked general SQL interview questions for intermediate to advanced professionals, especially useful if you’re preparing for roles like Database Developer, Data Engineer, SQL Analyst or DBA.

1. What are the largest databases or datasets you’ve worked with?
Be ready to describe the scale of data (e.g., millions of records, terabytes of storage) and your role in managing it. Interviewers want to know how you handled challenges related to performance, indexing or storage optimization at scale.

Example
I worked with a PostgreSQL database storing over 20 million transaction records per year. I optimized partitioning and used materialized views for performance.

2. How do you approach query optimization?
Explain your methodology for diagnosing and fixing slow queries. Mention tools like EXPLAIN PLAN, ANALYZE or SQL Server Profiler and strategies like using indexes, avoiding unnecessary joins, filtering early or optimizing subqueries and CTEs.

Example
I use EXPLAIN to analyze the query plan, then check for missing indexes, full table scans and unnecessary sorts.

In aspect of Query Optimization can read blog SQL Performance Tuning

3. Can you describe your experience with indexing strategies?
Discuss types of indexes you’ve used like clustered, non-clustered, composite, covering or filtered indexes and when each is appropriate. Mention index maintenance tasks like rebuilding/reorganizing fragmented indexes.

Example
For read-heavy reporting queries, I implemented covering indexes on the sales table, reducing query time by 60%.

4. How do you ensure data integrity in a multi-user environment?
Talk about transaction isolation levels, locking mechanisms, constraints and handling concurrent updates. Be ready to discuss deadlocks, race conditions and consistency strategies like ACID compliance.

Example
To prevent dirty reads in critical financial systems, I use SERIALIZABLE isolation and optimistic concurrency controls

5. Have you worked on database normalization and denormalization?
Describe situations where you normalized data to eliminate redundancy or denormalized to improve performance. Include the impact on storage, query speed and complexity.

Example
For OLTP systems, I use 3NF. But for reporting dashboards, I denormalize heavily for performance.

6. How do you handle schema changes in production databases?
Explain your process for applying schema migrations with zero downtime, including version control, staging environments, rollback strategies and using tools like Liquibase, Flyway or custom scripts.

Example
I use Flyway to track schema versions, apply changes incrementally and test extensively in staging before production rollout.

7. Describe your experience with views, materialized views or CTEs.
Talk about your use cases for each like views for abstraction, CTEs for readability or recursion and materialized views for performance improvements.

Example
I used a materialized view to pre-aggregate daily user metrics, improving dashboard load times from 10s to under 1s.

8. Have you worked with partitioned tables or sharding?
Mention experience with table partitioning (range, list, hash) for managing large tables, and sharding strategies for horizontal scaling in distributed systems.

Example
In a high-traffic e-commerce app, I used range partitioning on the order date to archive older data and improve lookup speed.

9. What’s your approach to managing database backups and recovery?
Discuss backup strategies like full, incremental, point-in-time recovery and how you’ve tested or implemented disaster recovery plans (e.g., replication, failover clusters).

Example
For PostgreSQL, I set up daily base backups with WAL archiving and tested PITR using pgBackRest.

10. How do you monitor and troubleshoot database performance?
Explain the tools and techniques you use to detect issues like slow queries, blocking, deadlocks or CPU spikes. Mention tools like Prometheus, SQL Server DMVs, pg_stat_statements or performance schema in MySQL.

Example
I regularly monitor slow query logs and use pg_stat_statements to identify inefficient queries and optimize them.

✅ Tip : Use specific scenarios and metrics when answering these questions. Instead of saying “I optimized a slow query,” say “I reduced query execution time from 8s to 0.5s by indexing two columns and rewriting a subquery with a CTE.”

Technical SQL Interview Questions for Beginners
Let’s move on to technical questions to check your deeper understanding of SQL concepts, query optimization and database structures.

Tip : While answering try to give clear and practical answers. Focus on what works well and why. Don’t make things too complicated, just explain things in a simple way with examples if possible. Show that you understand how to use SQL effectively in real situations.

11. What’s the difference between WHERE and HAVING clause?
The WHERE clause filters individual rows before any grouping or aggregation takes place and The HAVING clause filters grouped/aggregated results after GROUP BY is applied.
29. Are Common Table Expressions (CTEs) better for performance compared to subqueries or temporary tables?
CTEs are great for readability, modularity and recursion, but they do not always offer performance improvements. In fact, depending on the database engine and how you use them, CTEs can sometimes be slower than subqueries or temp tables.

Technique	Readability	Performance	Materialization	Use Case
CTE (WITH clause)	✅ High	⚠️ Varies	Often materialized (engine-specific)	Recursive queries, modular logic
Subquery (inline)	🟡 Medium	✅ Can be better	Often optimized/folded by the engine	One-off usage
Temp Table	❌ Verbose	✅ Best for reuse/complex joins	Materialized and indexed	Multiple reuse or large datasets
Tip : CTEs are not inherently faster. Use them for clarity and recursive logic, but always check the execution plan. For performance-critical queries, compare with subqueries or temp tables and benchmark.

30. How do you detect and optimize slow SQL queries?
You detect slow SQL queries using query profiling tools, execution plans and performance metrics. Optimization involves analyzing the query execution plan, indexing strategy, table statistics, joins, filtering logic and server resource usage. You can follow below steps for Optimization Process

Analyze Execution Plan : Use tools like EXPLAIN, EXPLAIN ANALYZE or the execution plan viewer.
Check for Missing or Inefficient Indexes
Examine Joins and Filtering Logic : Ensure appropriate join types and push filters as early as possible in the plan.
Rewrite Inefficient Queries
Measure Query Stats : Look at runtime statistics, I/O, buffer cache hits and row estimates vs actuals.
If you want to dive deeper, explore SQL Performance Tuning

31. What is database normalization?
Database normalization is the process of organizing data in a relational database to minimize redundancy and ensure data integrity by dividing large, complex tables into smaller, well-structured tables. Each resulting table represents a single concept or entity and relationships between tables are maintained using foreign keys.

32. What are the differences Between DBMS and RDBMS
Both DBMS (Database Management System) and RDBMS (Relational Database Management System) are systems designed to manage data efficiently, but they differ significantly in terms of structure, functionality and use cases.

Feature	DBMS	RDBMS
Data Storage	Stores data as files, documents or tables	Stores data strictly in relational tables
Data Relationships	No relationships between data entities	Supports relationships via primary/foreign keys
Normalization	Not supported	Fully supports normalization to reduce redundancy
Data Integrity	Limited	Enforces integrity constraints (PK, FK, UNIQUE)
Multi-user Access	Limited or not efficient	Supports multiple concurrent users with consistency
ACID Transactions	Not guaranteed	Fully ACID-compliant for reliable transactions
Security & Access Control	Basic or minimal	Advanced user roles and permission handling
Examples	Microsoft Access, File System, XML DB	MySQL, PostgreSQL, Oracle, SQL Server
Scalability	Suitable for small apps or single users	Suitable for enterprise apps and large systems
Note : All RDBMS are DBMS, but ❌ not all DBMS are RDBMS.

RDBMS follows a strict relational model, while DBMS can be any system that stores and retrieves data.

33. Difference Between INNER JOIN and OUTER JOINs
Joins are used to combine rows from two or more tables based on a related column. Here's how different join types behave:

Join Type	Description
INNER JOIN	Returns only the rows with matching values in both tables
LEFT JOIN (Left Outer Join)	Returns all rows from the left table and matched rows from the right table (NULL if no match)
RIGHT JOIN (Right Outer Join)	Returns all rows from the right table and matched rows from the left table (NULL if no match)
FULL OUTER JOIN	Returns all rows from both tables. If there’s no match, fills with NULLs
Tip : Use INNER JOIN when you need only common data, and use OUTER JOINs when you want to retain unmatched records too.

34. Can you explain ACID properties in databases?
ACID is a set of four key properties that ensure reliable and consistent transactions in a database system.

Atomicity : A transaction is all-or-nothing. If one part fails, the entire transaction is rolled back. Partial changes are never saved.
Consistency : Ensures that a transaction brings the database from one valid state to another. All rules (constraints, triggers, FK) must be satisfied.
Isolation : Transactions are executed independently. Multiple transactions can run at the same time without interfering with each other.
Durability : Once a transaction is committed, changes are permanent even in case of power loss or crash.
35. When would you use a Stored Procedure vs a Trigger in SQL?
Both stored procedures and triggers are used to encapsulate logic in SQL, but they serve very different purposes

Use a Stored Procedure When
You need modular, reusable logic (e.g., sp_generate_invoice, sp_apply_discount).
You want to encapsulate complex business processes.
You need parameterized execution or conditional logic.
The process is called by an application or scheduler.
To be in control of when and how it's executed.
Example
CREATE PROCEDURE sp_update_salary (@emp_id INT, @bonus DECIMAL)
AS
BEGIN
  UPDATE employees
  SET salary = salary + @bonus
  WHERE emp_id = @emp_id;
END;
Use a Trigger When
You want automatic action on data changes (like INSERT, UPDATE or DELETE).
Enforcing audit logs
Replicate data changes to another table/log.
Enforcing hidden business rules at the database level.
Example
CREATE TRIGGER trg_audit_employees
AFTER UPDATE ON employees
FOR EACH ROW
BEGIN
  INSERT INTO audit_log(emp_id, old_salary, new_salary, changed_on)
  VALUES (OLD.emp_id, OLD.salary, NEW.salary, CURRENT_TIMESTAMP);
END;
36. What are constraints in SQL and why use them?
Constraints are rules applied to table columns to make sure the data is valid, accurate and consistent. They help prevent bad or incorrect data from being stored in the database.

PRIMARY KEY: Uniquely identifies each row
FOREIGN KEY: Maintains referential integrity (Ensures values match those in another table).
NOT NULL: Prevents a column from having NULL values.
UNIQUE: Ensures all values in a column are different i.e. Prevents duplicate values.
CHECK: Validates that values meet a specific condition
DEFAULT: Sets a default value if none is provided
Example
CREATE TABLE users (
  id INT PRIMARY KEY,
  email VARCHAR(100) UNIQUE NOT NULL
);
37. What are Indexes in SQL?
An index in SQL is a performance-boosting data structure that helps the database quickly find rows without scanning the entire table.

Think of it like a book index, instead of reading every page to find a topic, you look it up in the index and jump straight to the right page.

38. Why to use Indexes?
Indexes make data retrieval much faster and more efficient. Without an index, the database has to perform a full table scan, checking every row one by one to find a match. which can be slow, especially on large tables. With an index, the database can quickly jump to the rows it needs, improving the performance of queries like SELECT, JOIN, WHERE and ORDER BY.

In short : Indexes reduce the amount of work the database has to do, helping your queries run faster and more efficiently, especially on large datasets.

39. What are key Benefits of Using Indexes
Faster Data Retrieval : Speeds up SELECT queries, especially on large tables.
Better Use of Joins : Speeds up joins by indexing foreign and primary keys.
Improved Application Performance : Enhances read operations in applications, reducing response time.
Enforcing Uniqueness : Unique indexes prevent duplicate entries in a column (like email).
Efficient Sorting and Filtering : Helps in ORDER BY, GROUP BY and WHERE clause queries.
40. What is Trade-off using Indexs?
While indexes can significantly speed up read operations, they come with certain downsides that you should be aware of

Slower Write Operations : INSERT, UPDATE and DELETE take longer because indexes need to be updated too.
Increased Storage : indexes take up extra disk space, especially if there are many or large indexes.
Maintenance Overhead : More indexes mean more work to manage, monitor and optimize over time.
Diminishing Returns : Adding too many indexes can actually hurt performance by confusing the query planner or slowing down queries.
Use indexes only where needed - only on columns frequently used in WHERE, JOIN, ORDER BY or GROUP BY clauses. Avoid indexing every column, as that can slow down write performance and waste storage.

41. How Do Indexes Work?
When you create an index on a column (or multiple columns), the database builds a separate lookup structure (usually a B-tree) that keeps the data in sorted order.

So, instead of going through the entire table row by row, the database uses this structure to jump directly to the relevant data, just like finding a word using a dictionary.

42. How to Create Indexes in SQL?
You can create indexes either while creating the table or after the table is created.

While Creating a Table
CREATE TABLE Customers (
    CustomerId INT PRIMARY KEY,
    FirstName VARCHAR(50),
    LastName VARCHAR(50),
    Email VARCHAR(100),
    INDEX idx_lastname (LastName)
);
After Table Creation
CREATE INDEX idx_email
ON Customers (Email);
43. What all different types of indexes in SQL
Index Type	Key Features	Best Use Case
Primary Index	- Unique
- No nulls
- Only one per table	Used as the main row identifier (e.g., user_id)
Unique Index	- Prevents duplicate values
- Allows nulls	Enforce uniqueness on fields like email, phone, username
Composite Index	- Combines multiple columns
- Index works best when queries use leftmost column(s)	Queries filtering by multiple fields (e.g., first_name, last_name)
Clustered Index	- Physically sorts and stores data rows
- Only one per table	Efficient for range or ordered queries (e.g., by created_at)
Non-Clustered Index	- Stores pointers to data
- Doesn’t change physical row order	Fast lookup queries without affecting storage order
Full-Text Index	- Specialized for large text
- Supports MATCH/AGAINST in MySQL/PostgreSQL	Searching in articles, blog posts, product descriptions
Spatial Index	- For spatial/geographic data
- Supports spatial relationships (e.g., distance, contains)	Location-based apps, GIS systems
Bitmap Index	- Uses bitmaps for values
- Ideal for low-cardinality columns (few unique values)	Data warehousing, analytics on columns like gender, status
JSON/XML Index	- Indexes specific keys/paths inside JSON or XML
- Improves structured queries on unstructured data	APIs, modern web apps storing structured documents
44. What is Index Selectivity and Why Does It Matter?
Index Selectivity measures how uniquely a column’s values identify rows in a table.

Selectivity = (Number of distinct values) / (Total number of rows)
High selectivity (e.g. email, user_id): Index is very effective.
Low selectivity (e.g. gender, is_active): Index may be ignored by the optimizer
Why it matters
The query planner uses indexes only when they help filter down the data significantly. Indexes on low-selectivity columns can even slow things down due to overhead.

45. What is a covering index?
A covering index is an index that contains all columns needed by a query, so the DBMS doesn’t need to access the base table.

Example
SELECT FirstName, LastName FROM Customers WHERE Email = 'a@b.com';
if you create

CREATE INDEX idx_email_name ON Customers (Email, FirstName, LastName);
This index covers the query (WHERE + SELECT columns), resulting in better performance.

46. What is the difference between Index Scan and Index Seek in SQL?
Feature	Index Seek	Index Scan
Definition	Efficient search that goes directly to the matching entry in the index.	Reads the entire index from start to finish.
Performance	Fast and selective, minimal I/O.	Slower, especially on large tables.
Usage	When query filters match indexed columns precisely with high selectivity.	When filter is missing, too broad or column has low selectivity.
Data Access	Uses B-tree traversal to locate relevant rows.	Scans all index rows and checks them one by one.
Predicate	SARGable (Search ARGument Able) : filter can use index efficiently.	Often non-SARGable (e.g., functions, LIKE '%x', type mismatch).
Tip : Aim for Index Seeks by writing SARGable queries and creating targeted indexes.

47. What set operators do you know in SQL?
SQL provides the following set operators to combine the results of two or more queries

UNION
Returns distinct rows from the result of two queries (duplicates are removed).

✅ Use when you want to merge results without duplicates.

UNION ALL
Returns all rows, including duplicates, from both queries.

✅ Faster than UNION, as it skips the distinct sort operation.

INTERSECT
Returns only the rows that are common to both queries.

✅ Useful for identifying overlaps between datasets.

EXCEPT (called MINUS in Oracle)
Returns rows that are in the first query but not in the second.

✅ Used to find non-overlapping differences between datasets.

Note : All participating queries must return the same number of columns, with compatible data types and column order.

48. What operator is used in SQL for pattern matching?
SQL uses the LIKE operator for pattern matching, typically in combination with wildcard characters:

% (percent) → Matches zero or more characters Example: 'A%' matches 'A', 'Alex', 'Amazon'
_ (underscore) → Matches exactly one character Example: 'A_' matches 'AB', 'Ax', but not 'Alex'
49. In which order does the SQL interpreter logically execute the sections of a SELECT query?
The system executes logically :

→ FROM
→ JOIN / ON
→ WHERE
→ GROUP BY
→ HAVING
→ SELECT
→ DISTINCT
→ ORDER BY
→ LIMIT (or OFFSET / TOP)
50. Is this the correct order of appearance for the common clauses in a SELECT statement?
 → SELECT 
 → FROM
 → JOIN
 → ON
 → WHERE
 → GROUP BY
 → HAVING
 → ORDER BY
 → LIMIT
51. What is a View in SQL?
A View is a virtual table based on a SQL query that retrieves data from one or more real tables (or even other views). It doesn’t store data itself, but dynamically presents it from the underlying tables.

Example
CREATE VIEW active_customers AS
SELECT id, name, email
FROM customers
WHERE status = 'active';

SQL Interview Questions: A Data Analyst's Guide for Success
Written by Coursera Staff • Updated on Jul 9, 2024
Share
Prepare for the SQL portion of your interview with example questions and a framework for answering them.

[Featured image] A person in a gray button-down sits at a computer workstation running SQL queries on a laptop
Being able to use SQL, or Structured Query Language, ranks among the most important skills for data analysts to have. As you prepare to interview for data analyst jobs, you can expect SQL to come up during the interview process.

With this guide, you’ll learn more about SQL technical screenings, what type of screening you might encounter, and some common types of questions that can arise during these interviews. You’ll also find some example questions, a step-by-step guide for writing SQL code during your interview, and tips for success. Let’s get started.  

What to expect from SQL technical screenings
Data analysts use SQL to communicate with relational databases to access, clean, and analyze data. At the time of writing, more than 230,000 jobs on LinkedIn included SQL in the listing. 

Since it’s such a critical skill, it’s common for data analyst interviews to include a SQL technical screening. This portion of the interview tasks you with solving real-world problems using SQL. While you may be asked some definitional questions that are more typical of a standard interview, the real point here is for the interviewer to verify that you can actually use SQL, not just talk about it. 

These screenings typically take one of three forms:

1. Whiteboard test: The most common type of SQL screening is the whiteboard interview. In this type of screening, you’re given a whiteboard and a marker to write out your queries by hand. Since you won’t have a computer alerting you to any syntax or logical errors in your code, this is more about demonstrating that you can think through a problem and know the right SQL concepts to solve it. 

2. Live coding: With this type of screening, you’ll be given SQL problems to solve in a live coding environment. This allows you to run your queries and check your work as you go, but syntax will matter since you’re running your code. Since different databases use different tools, this type of screening isn’t as common as the whiteboard screening.

3. Take-home assignment: With this less-common screening technique, you’ll be given a problem or series of problems to take home and solve within a given period. This lets you write your queries in the comfort of your home, without the pressure of an interviewer looking over your shoulder. On the other hand, the coding challenges are often more complex.

Related: 5 SQL Certifications for Your Data Career

Types of SQL interview questions for data analysts
Just as there are three formats technical screenings might take, there are also three broad categories of questions you’ll typically be asked during this portion of the interview. We’ve arranged them here from the most simple to the most complex. Generally speaking, the easier, definitional questions will be fewer and less important than the live coding questions—something to keep in mind as you prepare.

IBM
specialization

Data Analysis and Visualization Foundations
Get ahead w/ Data Analysis & Visualization skills. Enhance your career by learning to analyze data using Excel spreadsheets, and create stunning visualizations and interactive dashboards with Cognos.

4.8

(3,125 ratings)

46,663 already enrolled

Beginner level

Average time: 1 month(s)

Learn at your own pace

Skills you'll build:

Excel Formulas, Apache Hive, Data Analysis, Data Visualization, Tree Maps, Big Data, Apache Hadoop, Data Visualization Software, Data Science, Dashboard, Data Mining, Statistical Analysis, IBM Cognos Analytics, Data Wrangling, Data Collection, Data Storytelling, Data Warehousing, Microsoft Excel, Data Mart, Data Cleansing, Pivot Tables And Charts, Histogram, Scatter Plots, Data Quality, Exploratory Data Analysis, Data Manipulation, Data Import/Export, Information Privacy, Data Integrity, Google Sheets, Spreadsheet Software, Apache Spark, Data Lakes, Analytics

1. Define a SQL term
If you’re interviewing for a data analyst role, you probably know what SQL is (and your interviewer assumes you know this). It’s possible you’d be asked what SQL is, but you’ll more likely be asked to explain more technical concepts in SQL, the difference between two (or more) related concepts, or how a concept is used. This is not an exhaustive list, but here are some examples of terms you should be ready to explain:

Trigger: a procedure stored within a database, which automatically happens whenever a specific event occurs.

Index: a special lookup table within a database to increase data retrieval speed.

Cursor: a pointer, or identifier, associated with a single or group of rows.

Constraints: rules used to limit the type of data allowed within a table. Common constraints include primary key, foreign key, unique key, and NOT NULL.

ETL (Extract, transform, and load): a data integration process used to combine multiple data sources into one data store, such as a data warehouse.

Primary key, foreign key, and unique key: constraints used to identify records within a table.

Normalization vs. denormalization: techniques used to either divide data into multiple tables to achieve integrity ("normalization") or combine data into a table to increase the speed of data retrieval ("denormalization").

RDBMS vs. DBMS: two types of database management systems. Within a relational database management system (RDBMS) data is stored as a table, while in a database management system (DBMS) its stored as a file.


Clustered vs. non-clustered index: two types of indices used to sort and store data. A clustered index sorts data based on their key values, while a non-clustered index stores data and their records in separate locations.


Forms definitional questions may take:

What is the purpose of an index in a table? Explain the different types.

What are the types of joins in SQL?

What is the difference between DROP, TRUNCATE, and DELETE statements?

How do you use a cursor?

What is the difference between a HAVING clause and a WHERE clause?

Read more: SQL vs. MySQL: Differences, Similarities, Uses, and Benefits


2. Questions about a query
This second category gives you an SQL query and asks you a question about it. This tests your ability to read, interpret, analyze, and debug code written by others.

Forms query analysis questions may take:
Given a query,


Put the clauses in order by how SQL would run them.

Identify the error and correct it.

Predict what the query will return.

Explain what problem the query is meant to solve.


Learn more: SQL vs. NoSQL: The Differences Explained + When to Use Each

3. Write a query
The questions most commonly associated with the SQL technical screening ask you to solve a given problem by writing out a query in SQL. You’ll typically be given one or more tables and asked to write queries to retrieve, edit, or remove data from those tables.

The difficulty of questions will likely vary based on the company and the role (entry-level vs. advanced). In general, you should be comfortable writing queries using the following concepts, statements, and clauses:

Categorization, aggregation, and ratio (CASE, COUNT, or SUM, numerator and denominator)

Joining two tables (JOIN inner vs. left or right)

Modifying a database (INSERT, UPDATE, and DELETE)

Comparison operators (Less than, greater than, equal to)

Organizing data (ORDER BY, GROUP BY, HAVING)

Subqueries 

Forms query-writing questions may take:
Given a table or tables with a few sample rows,

List the three stores with the highest number of customer transactions.

Extract employee IDs for all employees who earned a three or higher on their last performance review.

Calculate the average monthly sales by product displayed in descending order.

Find and remove duplicates in the table without creating another table.

Identify the common records between two tables.

Video placeholder
Play Video
Eine Vorlesung aus dem Data Analytics Professional Certificate von Google.
Google
Analyze Data to Answer Questions
Google
4.6 (11,986 ratings)

 | 

740K Students Enrolled

Course 5 of 9 in the Google Data Analytics Professional Certificate

SQL interview tips for success
In addition to the process above, here are some tips for preparing for your SQL interview.

Talk through your process out loud. Your interviewer may or may not know SQL themselves, so be sure to explain the what, how, and why of each step.

Include written comments on what each step of your query is meant to accomplish. This can help you keep track of where you are in the problem and make your code easier to understand. If you’re coding in a live environment, you can type comments using a double hash (--). On a whiteboard, write your comments off to the side.

Use correct formatting. While your problem-solving ability is more important than precise syntax, you can avoid confusing the interviewer (and yourself) by keeping your hand-written code organized.

Embrace the awkwardness. It’s okay if the room is silent while you think through a problem. As you’re thinking out loud, you may find yourself re-starting sentences with a better way to explain something. That’s okay, too.

Read more: How to Prepare for an Interview

Six-step strategy for your SQL interview
Sometimes, the best way to calm nerves before an interview is to walk into the screening with a clear action plan. No matter what type of query you’re asked to write, you can use this six-step process to organize your thoughts and guide you to a solution, even when you’re nervous.

1. Restate the question to ensure you understand what you’re asked to do.

2. Explore the data by asking questions. What data type is in each column? Do any columns contain unique data (such as user ID)? 

3. Identify the columns you’ll need to solve the problem. This helps you focus on the data that matters so you’re not distracted by data irrelevant to the query.

4. Think about what your answer should look like. Are you looking for a single value or a list? Will the answer be the result of a calculation? If so, should it be a float or an integer? Do you need to account for this in your code?

5. Write your code one step at a time. It can help to outline your approach first. By writing down the steps you plan to take, you’ll have a clear outline once you start writing your query (and you’ll give the interviewer a chance to correct you if there’s an issue with your approach).

Then, code in increments, taking one step of your outline at a time. After you’re happy with your code for the first step, build onto that code with the second step. 

6. Explain your solution as a whole.  If there’s a more efficient way you could have written your code—using subqueries, for example—explain that. And remember to answer the original question.


SQL Interview Questions at a Glance
Throughout this article, we'll explore a range of SQL interview questions and answers for practitioners at the beginner and intermediate levels. If you're looking for an overview, we've compiled some top tips below:

For beginners
General questions. Expect questions about your experience, the SQL flavors you're familiar with, and your level of proficiency.
Technical questions. These will cover the basics of SQL, such as what it is, its applications, SQL statements, SQL commands, and types of SQL queries, among others.
For intermediate practitioners
Functions in SQL. You should know about aggregate and scalar functions, as well as built-in and user-defined functions.

Advanced commands. Questions may cover topics like joins, primary and foreign keys, indexes, and SQL relationships.

Database design. Expect questions on normalization, denormalization, and the differences between various SQL statements like DELETE, TRUNCATE, and DROP.

Advanced queries. You may be asked about subqueries, both nested and correlated, as well as how to perform specific tasks like finding the nth highest value in a column.

General SQL Interview Questions for Beginners
Before asking you technical questions, your interviewer may ask you some general questions about your overall experience with SQL. You can expect the following questions:

What SQL flavors are you familiar with?
How can you estimate your level of proficiency in SQL?
For how long have you been working in SQL?
While this information can be mentioned in your resume, be ready to talk about it. Naturally, there are no "right" answers to such questions, and there is no need to make up things when answering them.

Don't worry if your experience in SQL is limited: this is something your interviewer, most probably, already knows from your resume. Since they are interested in talking to you anyway, your profile was considered a good fit for their company.

Also, it's perfectly fine if you have only worked with one SQL flavor. Remember that all SQL dialects are fairly similar. Therefore, being familiar with only one of them is a solid basis for you to learn any others.

Technical SQL Interview Questions for Beginners 
Now, let's move on to the technical SQL interview questions and some potential answers to them.

When answering technical questions, the best strategy is to give as precise answers as possible. It may look like an attempt to deviate from the main topic. In addition, it may provoke additional questions about which you can feel less confident.

1. What is SQL?
It stands for Structured Query Language, and it's a programming language used for interaction with relational database management systems (RDBMS). This includes fetching, updating, inserting, and removing data from tables.

2. What are SQL dialects? Give some examples.
The various versions of SQL, both free and paid, are also called SQL dialects. All the flavors of SQL have a very similar syntax and vary insignificantly only in additional functionality. Some examples are Microsoft SQL Server, PostgreSQL, MySQL, SQLite, T-SQL, and Oracle.

3. What are the main applications of SQL?
Using SQL, we can:

create, delete, and update tables in a database
access, manipulate, and modify data in a table
retrieve and summarize the necessary information from a table or several tables
add or remove certain rows or columns from a table
All in all, SQL allows querying a database in multiple ways. In addition, SQL easily integrates with other programming languages, such as Python or R, so we can use their combined power.

4. What is an SQL statement? Give some examples.
Also known as an SQL command. It's a string of characters interpreted by the SQL engine as a legal command and executed accordingly. Some examples of SQL statements are SELECT, CREATE, DELETE, DROP, REVOKE, and so on.

5. What types of SQL commands (or SQL subsets) do you know?
Data Definition Language (DDL) – to define and modify the structure of a database.
Data Manipulation Language (DML) – to access, manipulate, and modify data in a database.
Data Control Language (DCL) – to control user access to the data in the database and give or revoke privileges to a specific user or a group of users.
Transaction Control Language (TCL) – to control transactions in a database.
Data Query Language (DQL) – to perform queries on the data in a database to retrieve the necessary information from it.
6. Give some examples of common SQL commands of each type.
DDL: CREATE, ALTER TABLE, DROP, TRUNCATE, and ADD COLUMN

DML: UPDATE, DELETE, and INSERT

DCL: GRANT and REVOKE

TCL: COMMIT, SET TRANSACTION, ROLLBACK, and SAVEPOINT

DQL: – SELECT

7. What is a database?
A structured storage space where the data is kept in many tables and organized so that the necessary information can be easily fetched, manipulated, and summarized.

8. What is DBMS, and what types of DBMS do you know?
It stands for Database Management System, a software package used to perform various operations on the data stored in a database, such as accessing, updating, wrangling, inserting, and removing data. There are various types of DBMS, such as relational, hierarchical, network, graph, or object-oriented. These types are based on the way the data is organized, structured, and stored in the system.

9. What is RDBMS? Give some examples of RDBMS.
It stands for Relational Database Management System. It's the most common type of DBMS used for working with data stored in multiple tables related to each other by means of shared keys. The SQL programming language is designed to interact with RDBMS. Some examples of RDBMS are MySQL, PostgreSQL, Oracle, MariaDB, etc.

10. What are tables and fields in SQL?
A table is an organized set of related data stored in a tabular form, i.e., in rows and columns. A field is another term for a column of a table.

11. What is an SQL query, and what types of queries do you know?
A query is a piece of code written in SQL to access or modify data from a database.

There are two types of SQL queries: select and action queries. The first ones are used to retrieve the necessary data (this also includes limiting, grouping, ordering the data, extracting the data from multiple tables, etc.), while the second ones are used to create, add, delete, update, rename the data, etc.

12. What is a subquery?
Also called an inner query, a query placed inside another query, or an outer query. A subquery may occur in the clauses such as SELECT, FROM, WHERE, UPDATE, etc. It's also possible to have a subquery inside another subquery. The innermost subquery is run first, and its result is passed to the containing query (or subquery).

13. What types of SQL subqueries do you know?
Single-row – returns at most one row.
Multi-row – returns at least two rows.
Multi-column – returns at least two columns.
Correlated – a subquery related to the information from the outer query.
Nested – a subquery inside another subquery.
14. What is a constraint, and why use constraints?
A set of conditions defining the type of data that can be input into each column of a table. Constraints ensure data integrity in a table and block undesired actions.

15. What SQL constraints do you know?
DEFAULT – provides a default value for a column.

UNIQUE – allows only unique values.

NOT NULL – allows only non-null values.

PRIMARY KEY – allows only unique and strictly non-null values (NOT NULL and UNIQUE).

FOREIGN KEY – provides shared keys between two or more tables.

16. What is a join?
A clause used to combine and retrieve records from two or multiple tables. SQL tables can be joined based on the relationship between the columns of those tables. Check out our SQL joins tutorial for more context, plus our dedicated guide to SQL joins interview questions. 

17. What types of joins do you know?
(INNER) JOIN – returns only those records that satisfy a defined join condition in both (or all) tables. It's a default SQL join.

LEFT (OUTER) JOIN – returns all records from the left table and those records from the right table that satisfy a defined join condition.

RIGHT (OUTER) JOIN – returns all records from the right table and those records from the left table that satisfy a defined join condition.

FULL (OUTER) JOIN – returns all records from both (or all) tables. It can be considered as a combination of left and right joins.

Note: FULL OUTER JOIN is supported by PostgreSQL, SQL Server, Oracle, and MySQL 8.0 and above, but MySQL only allows it through UNION patterns; meanwhile, SQLite does not support RIGHT JOIN, which can be emulated using LEFT JOIN in combination with UNION.

18. What is a primary key?
A column (or multiple columns) of a table to which the PRIMARY KEY constraint was imposed to ensure unique and non-null values in that column. In other words, a primary key is a combination of the NOT NULL and UNIQUE constraints. The primary key uniquely identifies each record of the table. Each table can define at most one PRIMARY KEY (which may be composite). A PRIMARY KEY  is strongly recommended but not strictly required by all engines.

19. What is a unique key?
A column (or multiple columns) of a table to which the UNIQUE constraint was imposed to ensure unique values in that column, including a possible NULL value (the only one).

Note: 

SQL Server: Only one NULL allowed unless you use a filtered index.
PostgreSQL / Oracle / MySQL: Multiple NULLs allowed because NULL <> NULL.
20. What is a foreign key? 
A column (or multiple columns) of a table to which the FOREIGN KEY (or UNIQUE key) constraint was imposed to link this column to the primary key in another table (or several tables). The purpose of foreign keys is to keep connected various tables of a database.

21. What is an index?
A special data structure related to a database table and used for storing its important parts and enabling faster data search and retrieval. Indexes are especially efficient for large databases, where they significantly enhance query performance.

22. What types of indexes do you know?
Unique index – doesn't allow duplicates in a table column and hence helps maintain data integrity.
Clustered index – defines the physical order of records of a database table and performs data searching based on the key values. A table can have only one clustered index.
Non-clustered index – keeps the order of the table records that don't match the physical order of the actual data on the disk. It means that the data is stored in one place and a non-clustered index – in another one. A table can have multiple non-clustered indexes.
23. What is a schema?
A collection of database structural elements such as tables, stored procedures, indexes, functions, and triggers. It shows the overall database architecture, specifies the relationships between various objects of a database, and defines different access permissions for them. Read our database schema guide for a deeper understanding.

24. What is a SQL comment?
A human-readable clarification of what a particular piece of code does. SQL code comments can be single-line (preceded by a double dash --) or span over multiple lines (as follows: /*comment_text*/). When the SQL engine runs, it ignores code comments. The purpose of adding SQL code comments is to make the code more comprehensive for those people who will read it in the future.

25. What is a SQL operator?
A reserved character, a combination of characters, or a keyword used in SQL queries to perform a specific operation. SQL operators are commonly used with the WHERE clause to set a condition (or conditions) for filtering the data.

26. What types of SQL operators do you know?
Arithmetic (+, -, *, /, etc.)

Comparison (>, <, =, >=, etc.)

Compound (+=, -=, *=, /=, etc.)

Logical (AND, OR, NOT, BETWEEN, etc.)

String (%, _, +, ^, etc.)

Set (UNION, UNION ALL, INTERSECT, and MINUS (or EXCEPT))

27. What is an alias?
A temporary name given to a table (or a column in a table) while executing a certain SQL query. Aliases are used to improve the code readability and make the code more compact. An alias is introduced with the AS keyword:

SELECT col_1 AS column
FROM table_name;

Powered By 
28. What is a clause?
A condition imposed on a SQL query to filter the data to obtain the desired result. Some examples are WHERE, LIMIT, HAVING, LIKE, AND, OR, ORDER BY, etc.

29. What are some common statements used with the SELECT query?
The most common ones are FROM, GROUP BY, JOIN, WHERE, ORDER BY, LIMIT, and HAVING.

30. How to create a table?
Using the CREATE TABLE statement. For example, to create a table with three columns of predefined datatypes, we apply the following syntax:

CREATE TABLE table_name (col_1 datatype,
                         col_2 datatype,
                         col_3 datatype);

Powered By 
31. How to update a table?
Using the UPDATE statement. The syntax is:

UPDATE table_name
SET col_1 = value_1, col_2 = value_2
WHERE condition;

Powered By 
32. How to delete a table from a database?
Using the DROP TABLE statement. The syntax is: DROP TABLE table_name;.

33. How to get the count of records in a table?
Using the COUNT() aggregate function with the asterisk passed as its argument: SELECT COUNT(*) FROM table_name;.

34. How to sort records in a table?
Using the ORDER BY statement:

SELECT * FROM table_name
ORDER BY col_1;

Powered By 
We can specify that we need a descending order using the DESC keyword; otherwise, the order will be ascending by default. Also, we can sort by more than one column and specify for each one, ascending or descending order separately. For example:

SELECT * FROM table_name
ORDER BY col_1 DESC, col_3, col_6 DESC;

Powered By 
35. How to select all columns from a table?
Using the asterisk * with the SELECT statement. The syntax is: SELECT * FROM table_name;.

36. How to select common records from two tables?
Using the INTERSECT statement:

SELECT col1, col2 FROM table_1
INTERSECT
SELECT col1, col2 FROM table_2;

Powered By 
Note: INTERSECT requires the same number of columns and compatible types.

37. What is the DISTINCT statement and how do you use it?
This statement is used with the SELECT statement to filter out duplicates and return only unique values from a column of a table. The syntax is:

SELECT DISTINCT col_1
FROM table_name;

Powered By 
38. What are relationships? Give some examples.
Relationships are the connections and correlations between entities, basically meaning how two or more tables of a database are related to one another. For example, we can find an ID of the same client in a table on sales data and in a customer table.

39. What is a NULL value? How is it different from zero or a blank space?
A NULL value indicates the absence of data for a certain cell of a table. Instead, zero is a valid numeric value, and an empty string is a legal string of zero length.

40. What is the difference between SQL and NoSQL?
SQL databases are relational, structured, and use tables with predefined schemas, while NoSQL databases are non-relational, schema-less, and designed to handle unstructured or semi-structured data.

41. What are some common challenges when working with SQL databases?
Challenges include performance tuning for large datasets, managing indexing strategies, ensuring data integrity with constraints, handling concurrent transactions, and optimizing query execution.

Intermediate SQL Interview Questions
In this section, we take a look at the most popular intermediate SQL questions and answers so that you'll know what to expect from your interviewer.

42. What is a function in SQL, and why use functions?
A database object representing a set of SQL statements frequently used for a certain task. A function takes in some input parameters, performs calculations or other manipulations on them, and returns the result. Functions help improve code readability and avoid repetition of the same code snippets.

43. What types of SQL functions do you know?
Aggregate functions – work on multiple, usually grouped records for the provided columns of a table, and return a single value (usually by group).
Scalar functions – work on each individual value and return a single value.
On the other hand, SQL functions can be built-in (defined by the system) or user-defined (created by the user for their specific needs).

44. What aggregate functions do you know?
AVG() – returns the average value

SUM() – returns the sum of values

MIN() – returns the minimum value

MAX() – returns the maximum value

COUNT() – returns the number of rows, including those with null values

FIRST() – returns the first value from a column

LAST()– returns the last value from a column

45. What scalar functions do you know?
LEN() (in other SQL flavors – LENGTH()) – returns the length of a string, including the blank spaces

UCASE() (in other SQL flavors – UPPER()) – returns a string converted to the upper case

LCASE() (in other SQL flavors – LOWER()) – returns a string converted to the lower case

INITCAP() – returns a string converted to the title case (i.e., each word of the string starts from a capital letter)

MID() (in other SQL flavors – SUBSTR()) – extracts a substring from a string

ROUND() – returns the numerical value rounded to a specified number of decimals

NOW() – returns the current date and time

46. What are case manipulation functions? Give some examples.
Case manipulation functions represent a subset of character functions, and they're used to change the case of the text data. With these functions, we can convert the data into the upper, lower, or title case.

UCASE() (in other SQL flavors – UPPER()) – returns a string converted to the upper case

LCASE() (in other SQL flavors – LOWER()) – returns a string converted to the lower case

INITCAP() – returns a string converted to the title case (i.e., each word of the string starts from a capital letter)

47. What are character manipulation functions? Give some examples.
Character manipulation functions represent a subset of character functions, and they're used to modify the text data.

CONCAT() – joins two or more string values appending the second string to the end of the first one

SUBSTRING()/SUBSTR() – returns a part of a string satisfying the provided start and end points

LENGTH() (in other SQL flavors – LEN()) – returns the length of a string, including the blank spaces

REPLACE() – replaces all occurrences of a defined substring in a provided string with another substring

INSTR() – returns the numeric position of a defined substring in a provided string

LPAD() and RPAD() – return the padding of the left-side/right-side character for right-justified/left-justified value

TRIM() – removes all the defined characters, as well as white spaces, from the left, right, or both ends of a provided string

48. What is the difference between local and global variables?
Local variables can be accessed only inside the function in which they were declared. Instead, global variables, being declared outside any function, are stored in fixed memory structures and can be used throughout the entire program.

49. What is the difference between SQL and PL/SQL?
SQL is a standard language for querying and managing relational databases, primarily used for data manipulation and retrieval. PL/SQL (Procedural Language/SQL) is an extension of SQL used in Oracle databases that includes procedural programming constructs like loops, conditions, and exception handling, allowing for complex business logic to be implemented within the database. We have another article on the Top 20 PL/SQL Interview Questions and Answers which is a good review if you know you will be asked about your knowledge of Oracle. 

50. What is the difference between LEFT JOIN and LEFT OUTER JOIN?
There is no difference between LEFT JOIN and LEFT OUTER JOIN. They are interchangeable. SQL allows the OUTER keyword to be optional, so LEFT JOIN is simply a shorthand for LEFT OUTER JOIN. Both return all records from the left table and the matching records from the right table.

51. What is indexing in SQL, and how does it improve performance?
Indexing creates a special data structure that speeds up data retrieval by allowing the database to find rows more efficiently. It works like an optimized lookup table, reducing the need for full table scans. However, excessive indexing can slow down insert, update, and delete operations due to the need for index maintenance.

52. What is a stored procedure, and how is it different from a function?
A stored procedure is a precompiled set of SQL statements executed as a unit to perform a task. Procedures can modify data or schema objects, manage transactions, and return zero or more result sets. Functions, on the other hand, are typically used in SQL expressions, must return a value (scalar or table-valued), and in many databases are restricted from side effects. Exact behavior differs by DB (e.g., T-SQL has scalar and table-valued functions; PostgreSQL distinguishes between functions and procedures).

53. What is the default data ordering with the ORDER BY statement, and how do you change it?
Default is ascending (NULLS FIRST/LAST varies by DB). Use ASC/DESC per column keyword as follows:

SELECT * FROM table_name 
ORDER BY col_1 DESC;

Powered By 
54. What set operators do you know?
UNION – returns the records obtained by at least one of two queries (excluding duplicates)

UNION ALL – returns the records obtained by at least one of two queries (including duplicates)

INTERSECT – returns the records obtained by both queries

EXCEPT (called MINUS in MySQL and Oracle) – returns only the records obtained by the first query but not the second one

55. What operator is used in the query for pattern matching?
The LIKE operator in combination with the % and _ wildcards. The % wildcard represents any number of characters including zero, while _ – strictly one character.

56. What is the difference between a primary key and a unique key?
While both types of keys ensure unique values in a column of a table, the first one uniquely identifies each record of the table, and the second one prevents duplicates in that column.

57. What is a composite primary key?
The primary key of a table, based on multiple columns.

58. What is the order of appearance of the common statements in the SELECT query?
SELECT – FROM – JOIN – ON – WHERE – GROUP BY – HAVING – ORDER BY – LIMIT

59. In which order does the interpreter execute the common statements in the SELECT query?
Here is the SQL order of execution: 

FROM → ON → JOIN → WHERE → GROUP BY → HAVING → SELECT → ORDER BY → LIMIT/OFFSET (FETCH)

60. What is a view, and why use it?
A virtual table containing a subset of data retrieved from one or more database tables (or other views). Standard views store no data; materialized views do. Views can simplify queries, encapsulate logic, and, combined with privileges, restrict columns/rows. They can join/aggregate data from multiple tables.

61. Can we create a view based on another view?
Yes. This is also known as nested views. However, we should avoid nesting multiple views since the code becomes difficult to read and debug.

62. Can we still use a view if the original table is deleted?
No. Any views based on that table will become invalid after deleting the base table. If we try to use such a view anyway, we'll receive an error message.

63. What types of SQL relationships do you know?
One-to-one – each record in one table corresponds to only one record in another table
One-to-many – each record in one table corresponds to several records in another table
Many-to-many – each record in both tables corresponds to several records in another table
64. What are the possible values of a BOOLEAN data field?
In some SQL flavors, such as PostgreSQL, the BOOLEAN data type exists explicitly and takes values TRUE, FALSE, or NULL. In other flavors, such as Microsoft SQL Server, the BIT datatype is used to store Boolean values as integers 1 (true) or 0 (false).

65. What is normalization in SQL, and why use it?
Normalization is a process of database design that includes organizing and restructuring data in a way to reduce data redundancy, dependency, duplication, and inconsistency. This leads to enhanced data integrity, more tables within the database, more efficient data access and security control, and greater query flexibility.

66. What is denormalization in SQL, and why use it?
Denormalization is the process opposite of normalization: it introduces data redundancy and combines data from multiple tables. Denormalization optimizes the performance of the database infrastructure in situations when read operations are more important than write operations since it helps avoid complex joins and reduces the time of query running.

67. What is the difference between renaming a column and giving an alias to it?
Renaming a column means permanently changing its actual name in the original table. Giving an alias to a column means giving it a temporary name while executing an SQL query, with the purpose to make the code more readable and compact.

68. What is the difference between nested and correlated subqueries?
A correlated subquery is an inner query nested in a bigger (outer) query that refers to the values from the outer query for its execution, meaning that a correlated subquery depends on its outer query. Instead, a non-correlated subquery doesn't rely on the data from the outer query and can be run independently of it.

69. What is the difference between clustered and non-clustered indexes?
While a clustered index defines the physical order of records of a table and performs data searching based on the key values, a non-clustered index keeps the order of records that do not match the physical order of the actual data on the disk. A table can have only one clustered index but many non-clustered ones.

70. What is the CASE() function?
The way to implement the if-then-else logic in SQL. This function sequentially checks the provided conditions in the WHEN clauses and returns the value from the corresponding THEN clause when the first condition is satisfied. If none of the conditions is satisfied, the function returns the value from the ELSE clause in case it's provided, otherwise, it returns NULL. The syntax is:

CASE
    WHEN condition_1 THEN value_1
    WHEN condition_2 THEN value_2
    WHEN condition_3 THEN value_3
    ...
    ELSE value
END;

Powered By 
71. What is the difference between the DELETE and TRUNCATE statements?
DELETE is a DML (Data Manipulation Language) command used to remove one or more rows from a table based on a condition in the WHERE clause. It is reversible only if wrapped in a transaction (via ROLLBACK).

TRUNCATE is a DDL (Data Definition Language) command that removes all rows from a table by deallocating pages. It is faster but generally irreversible, and cannot be used on tables that are referenced by a foreign key.

72. What is the difference between the DROP and TRUNCATE statements?
DROP deletes a table from the database completely, including the table structure and all the associated constraints, relationships with other tables, and access privileges. TRUNCATE deletes all rows from a table without affecting the table structure and constraints.  Both are DDL. DROP removes the table and its metadata; TRUNCATE deletes all rows but keeps the table definition. Performance and transactional behavior depend on the DB engine.

73. What is the difference between the HAVING and WHERE statements?
The first one works on aggregated data after they are grouped, while the second one checks each row individually. If both statements are present in a query, they appear in the following order: WHERE – GROUP BY – HAVING. The SQL engine interprets them also in the same order.

74. How do you add a record to a table?
Using the INSERT INTO statement in combination with VALUES. The syntax is:

INSERT INTO table_name
VALUES (value_1, value_2, ...);

Powered By 
75. How do you delete a record from a table?
Using the DELETE statement. The syntax is:

DELETE FROM table_name
WHERE condition;

Powered By 
In this way, we can also delete multiple records if they satisfy the provided condition.

76. How do you add a column to a table?
Using the ALTER TABLE statement in combination with ADD. The syntax is:

ALTER TABLE table_name
ADD column_name datatype;

Powered By 
77. How do you rename a column of a table?
Using the ALTER TABLE statement in combination with RENAME COLUMN ... TO ... The syntax is:

ALTER TABLE table_name
RENAME COLUMN old_column_name TO new_column_name;

Powered By 
78. How do you delete a column from a table?
Using the ALTER TABLE statement in combination with DROP COLUMN. The syntax is:

ALTER TABLE table_name
DROP COLUMN column_name;

Powered By 
79. How do you select all even or all odd records in a table?
By checking the remainder of the division by 2. In some SQL versions (e.g., PostgreSQL and My SQL), we use the MOD function, in the others (Microsoft SQL Server and SQLite) – the modulo operator (%). To select all even records using MOD:

SELECT * FROM table_name
WHERE MOD(ID_column, 2) = 0;

Powered By 
To select all even records using %:

SELECT * FROM table_name 
WHERE ID_column % 2 = 0;

Powered By 
To select all odd records, the syntax is identical in both cases, only that we would use the inequality operator <> instead of =.

80. How to prevent duplicate records when making a query?
Using the DISTINCT statement in combination with SELECT or creating a unique key for that table.

81. How do you insert many rows in a table?
Using the INSERT INTO statement in combination with VALUES. The syntax is:

INSERT INTO table_name
VALUES (value_1, value_2, ...),
      (value_3, value_4, ...),
      (value_5, value_6, ...),
      ...;

Powered By 
82. How do you find the nth highest value in a column of a table?
Using window functions to handle ties correctly:

SELECT column_name
FROM (
  SELECT column_name, DENSE_RANK() OVER (ORDER BY column_name DESC) AS rnk
  FROM table_name
) t
WHERE rnk = :n;

Powered By 
For the nth row by order (ignoring ties): ORDER BY column_name DESC OFFSET n-1 ROWS FETCH NEXT 1 ROW ONLY.

83. How do you find the values in a text column of a table that start with a certain letter?
Using the LIKE operator in combination with the % and _ wildcards. For example, we need to find all surnames in a table that start with "A". The query is:

SELECT * FROM table_name
WHERE surname LIKE 'A_';

Powered By 
Here, we assume that a surname must contain at least two letters. Without this assumption (meaning that a surname can be just A), the query is as follows:

SELECT * FROM table_name
WHERE surname LIKE 'A%';

Powered By 
84. How do you find the last id in a table?
The simplest method is to use the aggregate function MAX().

SELECT MAX(id) AS highest_id
FROM table_name;

Powered By 
Using ORDER BY with LIMIT or TOP

SELECT id
FROM table_name
ORDER BY id DESC
LIMIT 1;

Powered By 
85. How to select random rows from a table?
Using the RAND() function in combination with ORDER BY and LIMIT. In some SQL flavors, such as PostgreSQL, it's called RANDOM(). For example, the following code will return five random rows from a table in MySQL:

SELECT * FROM table_name
ORDER BY RAND()
LIMIT 5;


SQL Interview Questions at a Glance
Throughout this article, we'll explore a range of SQL interview questions and answers for practitioners at the beginner and intermediate levels. If you're looking for an overview, we've compiled some top tips below:

For beginners
General questions. Expect questions about your experience, the SQL flavors you're familiar with, and your level of proficiency.
Technical questions. These will cover the basics of SQL, such as what it is, its applications, SQL statements, SQL commands, and types of SQL queries, among others.
For intermediate practitioners
Functions in SQL. You should know about aggregate and scalar functions, as well as built-in and user-defined functions.

Advanced commands. Questions may cover topics like joins, primary and foreign keys, indexes, and SQL relationships.

Database design. Expect questions on normalization, denormalization, and the differences between various SQL statements like DELETE, TRUNCATE, and DROP.

Advanced queries. You may be asked about subqueries, both nested and correlated, as well as how to perform specific tasks like finding the nth highest value in a column.

General SQL Interview Questions for Beginners
Before asking you technical questions, your interviewer may ask you some general questions about your overall experience with SQL. You can expect the following questions:

What SQL flavors are you familiar with?
How can you estimate your level of proficiency in SQL?
For how long have you been working in SQL?
While this information can be mentioned in your resume, be ready to talk about it. Naturally, there are no "right" answers to such questions, and there is no need to make up things when answering them.

Don't worry if your experience in SQL is limited: this is something your interviewer, most probably, already knows from your resume. Since they are interested in talking to you anyway, your profile was considered a good fit for their company.

Also, it's perfectly fine if you have only worked with one SQL flavor. Remember that all SQL dialects are fairly similar. Therefore, being familiar with only one of them is a solid basis for you to learn any others.

Technical SQL Interview Questions for Beginners 
Now, let's move on to the technical SQL interview questions and some potential answers to them.

When answering technical questions, the best strategy is to give as precise answers as possible. It may look like an attempt to deviate from the main topic. In addition, it may provoke additional questions about which you can feel less confident.

1. What is SQL?
It stands for Structured Query Language, and it's a programming language used for interaction with relational database management systems (RDBMS). This includes fetching, updating, inserting, and removing data from tables.

2. What are SQL dialects? Give some examples.
The various versions of SQL, both free and paid, are also called SQL dialects. All the flavors of SQL have a very similar syntax and vary insignificantly only in additional functionality. Some examples are Microsoft SQL Server, PostgreSQL, MySQL, SQLite, T-SQL, and Oracle.

3. What are the main applications of SQL?
Using SQL, we can:

create, delete, and update tables in a database
access, manipulate, and modify data in a table
retrieve and summarize the necessary information from a table or several tables
add or remove certain rows or columns from a table
All in all, SQL allows querying a database in multiple ways. In addition, SQL easily integrates with other programming languages, such as Python or R, so we can use their combined power.

4. What is an SQL statement? Give some examples.
Also known as an SQL command. It's a string of characters interpreted by the SQL engine as a legal command and executed accordingly. Some examples of SQL statements are SELECT, CREATE, DELETE, DROP, REVOKE, and so on.

5. What types of SQL commands (or SQL subsets) do you know?
Data Definition Language (DDL) – to define and modify the structure of a database.
Data Manipulation Language (DML) – to access, manipulate, and modify data in a database.
Data Control Language (DCL) – to control user access to the data in the database and give or revoke privileges to a specific user or a group of users.
Transaction Control Language (TCL) – to control transactions in a database.
Data Query Language (DQL) – to perform queries on the data in a database to retrieve the necessary information from it.
6. Give some examples of common SQL commands of each type.
DDL: CREATE, ALTER TABLE, DROP, TRUNCATE, and ADD COLUMN

DML: UPDATE, DELETE, and INSERT

DCL: GRANT and REVOKE

TCL: COMMIT, SET TRANSACTION, ROLLBACK, and SAVEPOINT

DQL: – SELECT

7. What is a database?
A structured storage space where the data is kept in many tables and organized so that the necessary information can be easily fetched, manipulated, and summarized.

8. What is DBMS, and what types of DBMS do you know?
It stands for Database Management System, a software package used to perform various operations on the data stored in a database, such as accessing, updating, wrangling, inserting, and removing data. There are various types of DBMS, such as relational, hierarchical, network, graph, or object-oriented. These types are based on the way the data is organized, structured, and stored in the system.

9. What is RDBMS? Give some examples of RDBMS.
It stands for Relational Database Management System. It's the most common type of DBMS used for working with data stored in multiple tables related to each other by means of shared keys. The SQL programming language is designed to interact with RDBMS. Some examples of RDBMS are MySQL, PostgreSQL, Oracle, MariaDB, etc.

10. What are tables and fields in SQL?
A table is an organized set of related data stored in a tabular form, i.e., in rows and columns. A field is another term for a column of a table.

11. What is an SQL query, and what types of queries do you know?
A query is a piece of code written in SQL to access or modify data from a database.

There are two types of SQL queries: select and action queries. The first ones are used to retrieve the necessary data (this also includes limiting, grouping, ordering the data, extracting the data from multiple tables, etc.), while the second ones are used to create, add, delete, update, rename the data, etc.

12. What is a subquery?
Also called an inner query, a query placed inside another query, or an outer query. A subquery may occur in the clauses such as SELECT, FROM, WHERE, UPDATE, etc. It's also possible to have a subquery inside another subquery. The innermost subquery is run first, and its result is passed to the containing query (or subquery).

13. What types of SQL subqueries do you know?
Single-row – returns at most one row.
Multi-row – returns at least two rows.
Multi-column – returns at least two columns.
Correlated – a subquery related to the information from the outer query.
Nested – a subquery inside another subquery.
14. What is a constraint, and why use constraints?
A set of conditions defining the type of data that can be input into each column of a table. Constraints ensure data integrity in a table and block undesired actions.

15. What SQL constraints do you know?
DEFAULT – provides a default value for a column.

UNIQUE – allows only unique values.

NOT NULL – allows only non-null values.

PRIMARY KEY – allows only unique and strictly non-null values (NOT NULL and UNIQUE).

FOREIGN KEY – provides shared keys between two or more tables.

16. What is a join?
A clause used to combine and retrieve records from two or multiple tables. SQL tables can be joined based on the relationship between the columns of those tables. Check out our SQL joins tutorial for more context, plus our dedicated guide to SQL joins interview questions. 

17. What types of joins do you know?
(INNER) JOIN – returns only those records that satisfy a defined join condition in both (or all) tables. It's a default SQL join.

LEFT (OUTER) JOIN – returns all records from the left table and those records from the right table that satisfy a defined join condition.

RIGHT (OUTER) JOIN – returns all records from the right table and those records from the left table that satisfy a defined join condition.

FULL (OUTER) JOIN – returns all records from both (or all) tables. It can be considered as a combination of left and right joins.

Note: FULL OUTER JOIN is supported by PostgreSQL, SQL Server, Oracle, and MySQL 8.0 and above, but MySQL only allows it through UNION patterns; meanwhile, SQLite does not support RIGHT JOIN, which can be emulated using LEFT JOIN in combination with UNION.

18. What is a primary key?
A column (or multiple columns) of a table to which the PRIMARY KEY constraint was imposed to ensure unique and non-null values in that column. In other words, a primary key is a combination of the NOT NULL and UNIQUE constraints. The primary key uniquely identifies each record of the table. Each table can define at most one PRIMARY KEY (which may be composite). A PRIMARY KEY  is strongly recommended but not strictly required by all engines.

19. What is a unique key?
A column (or multiple columns) of a table to which the UNIQUE constraint was imposed to ensure unique values in that column, including a possible NULL value (the only one).

Note: 

SQL Server: Only one NULL allowed unless you use a filtered index.
PostgreSQL / Oracle / MySQL: Multiple NULLs allowed because NULL <> NULL.
20. What is a foreign key? 
A column (or multiple columns) of a table to which the FOREIGN KEY (or UNIQUE key) constraint was imposed to link this column to the primary key in another table (or several tables). The purpose of foreign keys is to keep connected various tables of a database.

21. What is an index?
A special data structure related to a database table and used for storing its important parts and enabling faster data search and retrieval. Indexes are especially efficient for large databases, where they significantly enhance query performance.

22. What types of indexes do you know?
Unique index – doesn't allow duplicates in a table column and hence helps maintain data integrity.
Clustered index – defines the physical order of records of a database table and performs data searching based on the key values. A table can have only one clustered index.
Non-clustered index – keeps the order of the table records that don't match the physical order of the actual data on the disk. It means that the data is stored in one place and a non-clustered index – in another one. A table can have multiple non-clustered indexes.
23. What is a schema?
A collection of database structural elements such as tables, stored procedures, indexes, functions, and triggers. It shows the overall database architecture, specifies the relationships between various objects of a database, and defines different access permissions for them. Read our database schema guide for a deeper understanding.

24. What is a SQL comment?
A human-readable clarification of what a particular piece of code does. SQL code comments can be single-line (preceded by a double dash --) or span over multiple lines (as follows: /*comment_text*/). When the SQL engine runs, it ignores code comments. The purpose of adding SQL code comments is to make the code more comprehensive for those people who will read it in the future.

25. What is a SQL operator?
A reserved character, a combination of characters, or a keyword used in SQL queries to perform a specific operation. SQL operators are commonly used with the WHERE clause to set a condition (or conditions) for filtering the data.

26. What types of SQL operators do you know?
Arithmetic (+, -, *, /, etc.)

Comparison (>, <, =, >=, etc.)

Compound (+=, -=, *=, /=, etc.)

Logical (AND, OR, NOT, BETWEEN, etc.)

String (%, _, +, ^, etc.)

Set (UNION, UNION ALL, INTERSECT, and MINUS (or EXCEPT))

27. What is an alias?
A temporary name given to a table (or a column in a table) while executing a certain SQL query. Aliases are used to improve the code readability and make the code more compact. An alias is introduced with the AS keyword:

SELECT col_1 AS column
FROM table_name;

Powered By 
28. What is a clause?
A condition imposed on a SQL query to filter the data to obtain the desired result. Some examples are WHERE, LIMIT, HAVING, LIKE, AND, OR, ORDER BY, etc.

29. What are some common statements used with the SELECT query?
The most common ones are FROM, GROUP BY, JOIN, WHERE, ORDER BY, LIMIT, and HAVING.

30. How to create a table?
Using the CREATE TABLE statement. For example, to create a table with three columns of predefined datatypes, we apply the following syntax:

CREATE TABLE table_name (col_1 datatype,
                         col_2 datatype,
                         col_3 datatype);

Powered By 
31. How to update a table?
Using the UPDATE statement. The syntax is:

UPDATE table_name
SET col_1 = value_1, col_2 = value_2
WHERE condition;

Powered By 
32. How to delete a table from a database?
Using the DROP TABLE statement. The syntax is: DROP TABLE table_name;.

33. How to get the count of records in a table?
Using the COUNT() aggregate function with the asterisk passed as its argument: SELECT COUNT(*) FROM table_name;.

34. How to sort records in a table?
Using the ORDER BY statement:

SELECT * FROM table_name
ORDER BY col_1;

Powered By 
We can specify that we need a descending order using the DESC keyword; otherwise, the order will be ascending by default. Also, we can sort by more than one column and specify for each one, ascending or descending order separately. For example:

SELECT * FROM table_name
ORDER BY col_1 DESC, col_3, col_6 DESC;

Powered By 
35. How to select all columns from a table?
Using the asterisk * with the SELECT statement. The syntax is: SELECT * FROM table_name;.

36. How to select common records from two tables?
Using the INTERSECT statement:

SELECT col1, col2 FROM table_1
INTERSECT
SELECT col1, col2 FROM table_2;

Powered By 
Note: INTERSECT requires the same number of columns and compatible types.

37. What is the DISTINCT statement and how do you use it?
This statement is used with the SELECT statement to filter out duplicates and return only unique values from a column of a table. The syntax is:

SELECT DISTINCT col_1
FROM table_name;

Powered By 
38. What are relationships? Give some examples.
Relationships are the connections and correlations between entities, basically meaning how two or more tables of a database are related to one another. For example, we can find an ID of the same client in a table on sales data and in a customer table.

39. What is a NULL value? How is it different from zero or a blank space?
A NULL value indicates the absence of data for a certain cell of a table. Instead, zero is a valid numeric value, and an empty string is a legal string of zero length.

40. What is the difference between SQL and NoSQL?
SQL databases are relational, structured, and use tables with predefined schemas, while NoSQL databases are non-relational, schema-less, and designed to handle unstructured or semi-structured data.

41. What are some common challenges when working with SQL databases?
Challenges include performance tuning for large datasets, managing indexing strategies, ensuring data integrity with constraints, handling concurrent transactions, and optimizing query execution.

Intermediate SQL Interview Questions
In this section, we take a look at the most popular intermediate SQL questions and answers so that you'll know what to expect from your interviewer.

42. What is a function in SQL, and why use functions?
A database object representing a set of SQL statements frequently used for a certain task. A function takes in some input parameters, performs calculations or other manipulations on them, and returns the result. Functions help improve code readability and avoid repetition of the same code snippets.

43. What types of SQL functions do you know?
Aggregate functions – work on multiple, usually grouped records for the provided columns of a table, and return a single value (usually by group).
Scalar functions – work on each individual value and return a single value.
On the other hand, SQL functions can be built-in (defined by the system) or user-defined (created by the user for their specific needs).

44. What aggregate functions do you know?
AVG() – returns the average value

SUM() – returns the sum of values

MIN() – returns the minimum value

MAX() – returns the maximum value

COUNT() – returns the number of rows, including those with null values

FIRST() – returns the first value from a column

LAST()– returns the last value from a column

45. What scalar functions do you know?
LEN() (in other SQL flavors – LENGTH()) – returns the length of a string, including the blank spaces

UCASE() (in other SQL flavors – UPPER()) – returns a string converted to the upper case

LCASE() (in other SQL flavors – LOWER()) – returns a string converted to the lower case

INITCAP() – returns a string converted to the title case (i.e., each word of the string starts from a capital letter)

MID() (in other SQL flavors – SUBSTR()) – extracts a substring from a string

ROUND() – returns the numerical value rounded to a specified number of decimals

NOW() – returns the current date and time

46. What are case manipulation functions? Give some examples.
Case manipulation functions represent a subset of character functions, and they're used to change the case of the text data. With these functions, we can convert the data into the upper, lower, or title case.

UCASE() (in other SQL flavors – UPPER()) – returns a string converted to the upper case

LCASE() (in other SQL flavors – LOWER()) – returns a string converted to the lower case

INITCAP() – returns a string converted to the title case (i.e., each word of the string starts from a capital letter)

47. What are character manipulation functions? Give some examples.
Character manipulation functions represent a subset of character functions, and they're used to modify the text data.

CONCAT() – joins two or more string values appending the second string to the end of the first one

SUBSTRING()/SUBSTR() – returns a part of a string satisfying the provided start and end points

LENGTH() (in other SQL flavors – LEN()) – returns the length of a string, including the blank spaces

REPLACE() – replaces all occurrences of a defined substring in a provided string with another substring

INSTR() – returns the numeric position of a defined substring in a provided string

LPAD() and RPAD() – return the padding of the left-side/right-side character for right-justified/left-justified value

TRIM() – removes all the defined characters, as well as white spaces, from the left, right, or both ends of a provided string

48. What is the difference between local and global variables?
Local variables can be accessed only inside the function in which they were declared. Instead, global variables, being declared outside any function, are stored in fixed memory structures and can be used throughout the entire program.

49. What is the difference between SQL and PL/SQL?
SQL is a standard language for querying and managing relational databases, primarily used for data manipulation and retrieval. PL/SQL (Procedural Language/SQL) is an extension of SQL used in Oracle databases that includes procedural programming constructs like loops, conditions, and exception handling, allowing for complex business logic to be implemented within the database. We have another article on the Top 20 PL/SQL Interview Questions and Answers which is a good review if you know you will be asked about your knowledge of Oracle. 

50. What is the difference between LEFT JOIN and LEFT OUTER JOIN?
There is no difference between LEFT JOIN and LEFT OUTER JOIN. They are interchangeable. SQL allows the OUTER keyword to be optional, so LEFT JOIN is simply a shorthand for LEFT OUTER JOIN. Both return all records from the left table and the matching records from the right table.

51. What is indexing in SQL, and how does it improve performance?
Indexing creates a special data structure that speeds up data retrieval by allowing the database to find rows more efficiently. It works like an optimized lookup table, reducing the need for full table scans. However, excessive indexing can slow down insert, update, and delete operations due to the need for index maintenance.

52. What is a stored procedure, and how is it different from a function?
A stored procedure is a precompiled set of SQL statements executed as a unit to perform a task. Procedures can modify data or schema objects, manage transactions, and return zero or more result sets. Functions, on the other hand, are typically used in SQL expressions, must return a value (scalar or table-valued), and in many databases are restricted from side effects. Exact behavior differs by DB (e.g., T-SQL has scalar and table-valued functions; PostgreSQL distinguishes between functions and procedures).

53. What is the default data ordering with the ORDER BY statement, and how do you change it?
Default is ascending (NULLS FIRST/LAST varies by DB). Use ASC/DESC per column keyword as follows:

SELECT * FROM table_name 
ORDER BY col_1 DESC;

Powered By 
54. What set operators do you know?
UNION – returns the records obtained by at least one of two queries (excluding duplicates)

UNION ALL – returns the records obtained by at least one of two queries (including duplicates)

INTERSECT – returns the records obtained by both queries

EXCEPT (called MINUS in MySQL and Oracle) – returns only the records obtained by the first query but not the second one

55. What operator is used in the query for pattern matching?
The LIKE operator in combination with the % and _ wildcards. The % wildcard represents any number of characters including zero, while _ – strictly one character.

56. What is the difference between a primary key and a unique key?
While both types of keys ensure unique values in a column of a table, the first one uniquely identifies each record of the table, and the second one prevents duplicates in that column.

57. What is a composite primary key?
The primary key of a table, based on multiple columns.

58. What is the order of appearance of the common statements in the SELECT query?
SELECT – FROM – JOIN – ON – WHERE – GROUP BY – HAVING – ORDER BY – LIMIT

59. In which order does the interpreter execute the common statements in the SELECT query?
Here is the SQL order of execution: 

FROM → ON → JOIN → WHERE → GROUP BY → HAVING → SELECT → ORDER BY → LIMIT/OFFSET (FETCH)

60. What is a view, and why use it?
A virtual table containing a subset of data retrieved from one or more database tables (or other views). Standard views store no data; materialized views do. Views can simplify queries, encapsulate logic, and, combined with privileges, restrict columns/rows. They can join/aggregate data from multiple tables.

61. Can we create a view based on another view?
Yes. This is also known as nested views. However, we should avoid nesting multiple views since the code becomes difficult to read and debug.

62. Can we still use a view if the original table is deleted?
No. Any views based on that table will become invalid after deleting the base table. If we try to use such a view anyway, we'll receive an error message.

63. What types of SQL relationships do you know?
One-to-one – each record in one table corresponds to only one record in another table
One-to-many – each record in one table corresponds to several records in another table
Many-to-many – each record in both tables corresponds to several records in another table
64. What are the possible values of a BOOLEAN data field?
In some SQL flavors, such as PostgreSQL, the BOOLEAN data type exists explicitly and takes values TRUE, FALSE, or NULL. In other flavors, such as Microsoft SQL Server, the BIT datatype is used to store Boolean values as integers 1 (true) or 0 (false).

65. What is normalization in SQL, and why use it?
Normalization is a process of database design that includes organizing and restructuring data in a way to reduce data redundancy, dependency, duplication, and inconsistency. This leads to enhanced data integrity, more tables within the database, more efficient data access and security control, and greater query flexibility.

66. What is denormalization in SQL, and why use it?
Denormalization is the process opposite of normalization: it introduces data redundancy and combines data from multiple tables. Denormalization optimizes the performance of the database infrastructure in situations when read operations are more important than write operations since it helps avoid complex joins and reduces the time of query running.

67. What is the difference between renaming a column and giving an alias to it?
Renaming a column means permanently changing its actual name in the original table. Giving an alias to a column means giving it a temporary name while executing an SQL query, with the purpose to make the code more readable and compact.

68. What is the difference between nested and correlated subqueries?
A correlated subquery is an inner query nested in a bigger (outer) query that refers to the values from the outer query for its execution, meaning that a correlated subquery depends on its outer query. Instead, a non-correlated subquery doesn't rely on the data from the outer query and can be run independently of it.

69. What is the difference between clustered and non-clustered indexes?
While a clustered index defines the physical order of records of a table and performs data searching based on the key values, a non-clustered index keeps the order of records that do not match the physical order of the actual data on the disk. A table can have only one clustered index but many non-clustered ones.

70. What is the CASE() function?
The way to implement the if-then-else logic in SQL. This function sequentially checks the provided conditions in the WHEN clauses and returns the value from the corresponding THEN clause when the first condition is satisfied. If none of the conditions is satisfied, the function returns the value from the ELSE clause in case it's provided, otherwise, it returns NULL. The syntax is:

CASE
    WHEN condition_1 THEN value_1
    WHEN condition_2 THEN value_2
    WHEN condition_3 THEN value_3
    ...
    ELSE value
END;

Powered By 
71. What is the difference between the DELETE and TRUNCATE statements?
DELETE is a DML (Data Manipulation Language) command used to remove one or more rows from a table based on a condition in the WHERE clause. It is reversible only if wrapped in a transaction (via ROLLBACK).

TRUNCATE is a DDL (Data Definition Language) command that removes all rows from a table by deallocating pages. It is faster but generally irreversible, and cannot be used on tables that are referenced by a foreign key.

72. What is the difference between the DROP and TRUNCATE statements?
DROP deletes a table from the database completely, including the table structure and all the associated constraints, relationships with other tables, and access privileges. TRUNCATE deletes all rows from a table without affecting the table structure and constraints.  Both are DDL. DROP removes the table and its metadata; TRUNCATE deletes all rows but keeps the table definition. Performance and transactional behavior depend on the DB engine.

73. What is the difference between the HAVING and WHERE statements?
The first one works on aggregated data after they are grouped, while the second one checks each row individually. If both statements are present in a query, they appear in the following order: WHERE – GROUP BY – HAVING. The SQL engine interprets them also in the same order.

74. How do you add a record to a table?
Using the INSERT INTO statement in combination with VALUES. The syntax is:

INSERT INTO table_name
VALUES (value_1, value_2, ...);

Powered By 
75. How do you delete a record from a table?
Using the DELETE statement. The syntax is:

DELETE FROM table_name
WHERE condition;

Powered By 
In this way, we can also delete multiple records if they satisfy the provided condition.

76. How do you add a column to a table?
Using the ALTER TABLE statement in combination with ADD. The syntax is:

ALTER TABLE table_name
ADD column_name datatype;

Powered By 
77. How do you rename a column of a table?
Using the ALTER TABLE statement in combination with RENAME COLUMN ... TO ... The syntax is:

ALTER TABLE table_name
RENAME COLUMN old_column_name TO new_column_name;

Powered By 
78. How do you delete a column from a table?
Using the ALTER TABLE statement in combination with DROP COLUMN. The syntax is:

ALTER TABLE table_name
DROP COLUMN column_name;

Powered By 
79. How do you select all even or all odd records in a table?
By checking the remainder of the division by 2. In some SQL versions (e.g., PostgreSQL and My SQL), we use the MOD function, in the others (Microsoft SQL Server and SQLite) – the modulo operator (%). To select all even records using MOD:

SELECT * FROM table_name
WHERE MOD(ID_column, 2) = 0;

Powered By 
To select all even records using %:

SELECT * FROM table_name 
WHERE ID_column % 2 = 0;

Powered By 
To select all odd records, the syntax is identical in both cases, only that we would use the inequality operator <> instead of =.

80. How to prevent duplicate records when making a query?
Using the DISTINCT statement in combination with SELECT or creating a unique key for that table.

81. How do you insert many rows in a table?
Using the INSERT INTO statement in combination with VALUES. The syntax is:

INSERT INTO table_name
VALUES (value_1, value_2, ...),
      (value_3, value_4, ...),
      (value_5, value_6, ...),
      ...;

Powered By 
82. How do you find the nth highest value in a column of a table?
Using window functions to handle ties correctly:

SELECT column_name
FROM (
  SELECT column_name, DENSE_RANK() OVER (ORDER BY column_name DESC) AS rnk
  FROM table_name
) t
WHERE rnk = :n;

Powered By 
For the nth row by order (ignoring ties): ORDER BY column_name DESC OFFSET n-1 ROWS FETCH NEXT 1 ROW ONLY.

83. How do you find the values in a text column of a table that start with a certain letter?
Using the LIKE operator in combination with the % and _ wildcards. For example, we need to find all surnames in a table that start with "A". The query is:

SELECT * FROM table_name
WHERE surname LIKE 'A_';

Powered By 
Here, we assume that a surname must contain at least two letters. Without this assumption (meaning that a surname can be just A), the query is as follows:

SELECT * FROM table_name
WHERE surname LIKE 'A%';

Powered By 
84. How do you find the last id in a table?
The simplest method is to use the aggregate function MAX().

SELECT MAX(id) AS highest_id
FROM table_name;

Powered By 
Using ORDER BY with LIMIT or TOP

SELECT id
FROM table_name
ORDER BY id DESC
LIMIT 1;

Powered By 
85. How to select random rows from a table?
Using the RAND() function in combination with ORDER BY and LIMIT. In some SQL flavors, such as PostgreSQL, it's called RANDOM(). For example, the following code will return five random rows from a table in MySQL:

SELECT * FROM table_name
ORDER BY RAND()
LIMIT 5;


Airbnb SQL Interview Study Guide
Advanced Analytics, Sr. Manager, Marketing

1. FILTERING & WHERE Clauses
Basic Filtering
-- Single condition
SELECT * FROM bookings
WHERE booking_date >= DATE '2024-01-01';

-- Multiple conditions
SELECT * FROM bookings
WHERE status = 'confirmed'
  AND total_price > 500
  AND guest_country = 'US';

-- IN operator
SELECT * FROM listings
WHERE city IN ('San Francisco', 'New York', 'Los Angeles');

-- LIKE pattern matching
SELECT * FROM listings
WHERE property_type LIKE '%Apartment%';

-- IS NULL / IS NOT NULL
SELECT * FROM reviews
WHERE response_date IS NULL;

Date Filtering in Presto
-- Current date functions
SELECT * FROM bookings
WHERE booking_date >= CURRENT_DATE - INTERVAL '30' DAY;

-- Date parsing
SELECT * FROM bookings
WHERE date_parse(booking_timestamp, '%Y-%m-%d') = DATE '2024-01-15';

-- Extract date parts
SELECT * FROM bookings
WHERE YEAR(booking_date) = 2024
  AND MONTH(booking_date) = 6;


2. AGGREGATING
Basic Aggregations
-- Common aggregate functions
SELECT 
    COUNT(*) as total_bookings,
    COUNT(DISTINCT guest_id) as unique_guests,
    SUM(total_price) as total_revenue,
    AVG(total_price) as avg_booking_value,
    MIN(booking_date) as first_booking,
    MAX(booking_date) as last_booking
FROM bookings;

GROUP BY
-- Single grouping
SELECT 
    listing_city,
    COUNT(*) as bookings,
    SUM(total_price) as revenue,
    AVG(nights_booked) as avg_nights
FROM bookings
WHERE booking_date >= DATE '2024-01-01'
GROUP BY listing_city
ORDER BY revenue DESC;

-- Multiple grouping
SELECT 
    listing_city,
    property_type,
    DATE_TRUNC('month', booking_date) as booking_month,
    COUNT(*) as bookings,
    SUM(total_price) as revenue
FROM bookings
GROUP BY listing_city, property_type, DATE_TRUNC('month', booking_date);

HAVING (filtering after aggregation)
SELECT 
    host_id,
    COUNT(*) as total_bookings,
    SUM(total_price) as total_revenue
FROM bookings
GROUP BY host_id
HAVING COUNT(*) >= 10  -- Only hosts with 10+ bookings
   AND SUM(total_price) > 5000;


3. JOINING TABLES
INNER JOIN
-- Returns only matching records from both tables
SELECT 
    b.booking_id,
    b.booking_date,
    b.total_price,
    l.property_name,
    l.city,
    g.guest_name,
    g.guest_email
FROM bookings b
INNER JOIN listings l ON b.listing_id = l.listing_id
INNER JOIN guests g ON b.guest_id = g.guest_id
WHERE b.booking_date >= DATE '2024-01-01';

LEFT JOIN
-- Returns all records from left table, matching records from right
SELECT 
    l.listing_id,
    l.property_name,
    l.city,
    COUNT(b.booking_id) as total_bookings,
    COALESCE(SUM(b.total_price), 0) as total_revenue
FROM listings l
LEFT JOIN bookings b ON l.listing_id = b.listing_id
    AND b.booking_date >= DATE '2024-01-01'
GROUP BY l.listing_id, l.property_name, l.city;

RIGHT JOIN & FULL OUTER JOIN
-- RIGHT JOIN: all records from right table
SELECT * 
FROM bookings b
RIGHT JOIN listings l ON b.listing_id = l.listing_id;

-- FULL OUTER JOIN: all records from both tables
SELECT * 
FROM bookings b
FULL OUTER JOIN listings l ON b.listing_id = l.listing_id;

Multiple Join Conditions
SELECT 
    b.booking_id,
    b.total_price,
    l.property_name
FROM bookings b
INNER JOIN listings l 
    ON b.listing_id = l.listing_id
    AND b.listing_city = l.city  -- Additional join condition
WHERE b.status = 'confirmed';


4. SUBQUERIES
Subquery in WHERE Clause
-- Find bookings for top 10% of listings by price
SELECT *
FROM bookings
WHERE listing_id IN (
    SELECT listing_id
    FROM listings
    WHERE nightly_rate > (
        SELECT PERCENTILE_CONT(0.9) WITHIN GROUP (ORDER BY nightly_rate)
        FROM listings
    )
);

Subquery in FROM Clause (Derived Tables)
-- Average bookings per city, then find cities above overall average
SELECT 
    city,
    avg_bookings
FROM (
    SELECT 
        listing_city as city,
        COUNT(*) as avg_bookings
    FROM bookings
    WHERE booking_date >= DATE '2024-01-01'
    GROUP BY listing_city
) city_stats
WHERE avg_bookings > (
    SELECT AVG(booking_count)
    FROM (
        SELECT COUNT(*) as booking_count
        FROM bookings
        WHERE booking_date >= DATE '2024-01-01'
        GROUP BY listing_city
    )
);

Correlated Subquery
-- Find listings with above-average bookings for their city
SELECT 
    l.listing_id,
    l.property_name,
    l.city,
    (SELECT COUNT(*) FROM bookings b WHERE b.listing_id = l.listing_id) as booking_count
FROM listings l
WHERE (
    SELECT COUNT(*) 
    FROM bookings b 
    WHERE b.listing_id = l.listing_id
) > (
    SELECT AVG(city_avg)
    FROM (
        SELECT COUNT(*) as city_avg
        FROM bookings b2
        INNER JOIN listings l2 ON b2.listing_id = l2.listing_id
        WHERE l2.city = l.city
        GROUP BY l2.listing_id
    )
);

EXISTS
-- Find guests who have made bookings in 2024
SELECT *
FROM guests g
WHERE EXISTS (
    SELECT 1
    FROM bookings b
    WHERE b.guest_id = g.guest_id
      AND YEAR(b.booking_date) = 2024
);


5. SELF-JOINS
Finding Relationships Within Same Table
-- Find guests who booked the same listing multiple times
SELECT 
    b1.guest_id,
    b1.listing_id,
    b1.booking_date as first_booking,
    b2.booking_date as second_booking,
    DATE_DIFF('day', b1.booking_date, b2.booking_date) as days_between
FROM bookings b1
INNER JOIN bookings b2 
    ON b1.guest_id = b2.guest_id
    AND b1.listing_id = b2.listing_id
    AND b1.booking_id < b2.booking_id  -- Avoid duplicates
WHERE b1.status = 'completed'
  AND b2.status = 'completed';

Finding Sequential Events
-- Find consecutive bookings for the same listing
SELECT 
    b1.listing_id,
    b1.booking_id as first_booking_id,
    b1.checkout_date,
    b2.booking_id as next_booking_id,
    b2.checkin_date,
    DATE_DIFF('day', b1.checkout_date, b2.checkin_date) as gap_days
FROM bookings b1
INNER JOIN bookings b2
    ON b1.listing_id = b2.listing_id
    AND b1.checkout_date < b2.checkin_date
WHERE NOT EXISTS (
    SELECT 1 FROM bookings b3
    WHERE b3.listing_id = b1.listing_id
      AND b3.checkin_date > b1.checkout_date
      AND b3.checkin_date < b2.checkin_date
);


6. WINDOW FUNCTIONS (Critical for Analytics!)
ROW_NUMBER, RANK, DENSE_RANK
SELECT 
    listing_id,
    booking_date,
    total_price,
    -- Assign unique row numbers
    ROW_NUMBER() OVER (PARTITION BY listing_id ORDER BY booking_date) as booking_sequence,
    -- Rank with gaps for ties
    RANK() OVER (PARTITION BY listing_id ORDER BY total_price DESC) as price_rank,
    -- Rank without gaps
    DENSE_RANK() OVER (ORDER BY total_price DESC) as dense_price_rank
FROM bookings;

Running Totals and Moving Averages
SELECT 
    booking_date,
    listing_id,
    total_price,
    -- Running total
    SUM(total_price) OVER (
        PARTITION BY listing_id 
        ORDER BY booking_date
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) as running_total,
    -- Moving average (last 7 days)
    AVG(total_price) OVER (
        PARTITION BY listing_id 
        ORDER BY booking_date
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) as moving_avg_7day,
    -- Total for the partition
    SUM(total_price) OVER (PARTITION BY listing_id) as listing_total
FROM bookings;

LAG and LEAD (Compare to Previous/Next Rows)
SELECT 
    listing_id,
    booking_date,
    total_price,
    -- Previous booking price
    LAG(total_price, 1) OVER (
        PARTITION BY listing_id 
        ORDER BY booking_date
    ) as prev_price,
    -- Next booking date
    LEAD(booking_date, 1) OVER (
        PARTITION BY listing_id 
        ORDER BY booking_date
    ) as next_booking_date,
    -- Calculate change from previous
    total_price - LAG(total_price, 1) OVER (
        PARTITION BY listing_id 
        ORDER BY booking_date
    ) as price_change
FROM bookings;

FIRST_VALUE and LAST_VALUE
SELECT 
    booking_id,
    listing_id,
    booking_date,
    total_price,
    -- First booking price for this listing
    FIRST_VALUE(total_price) OVER (
        PARTITION BY listing_id 
        ORDER BY booking_date
    ) as first_booking_price,
    -- Last booking price in the window
    LAST_VALUE(total_price) OVER (
        PARTITION BY listing_id 
        ORDER BY booking_date
        ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
    ) as last_booking_price
FROM bookings;

NTILE (Create Buckets)
SELECT 
    listing_id,
    total_price,
    -- Divide into quartiles
    NTILE(4) OVER (ORDER BY total_price) as price_quartile,
    -- Divide by city into deciles
    NTILE(10) OVER (PARTITION BY city ORDER BY total_price) as city_price_decile
FROM bookings;


7. COMMON PRESTO-SPECIFIC SYNTAX
Date/Time Functions
-- Current timestamp
SELECT CURRENT_TIMESTAMP, CURRENT_DATE, CURRENT_TIME;

-- Date arithmetic
SELECT 
    booking_date,
    booking_date + INTERVAL '7' DAY as week_later,
    booking_date - INTERVAL '1' MONTH as month_earlier;

-- Date difference
SELECT DATE_DIFF('day', checkin_date, checkout_date) as nights;

-- Date truncation
SELECT 
    DATE_TRUNC('month', booking_date) as booking_month,
    DATE_TRUNC('quarter', booking_date) as booking_quarter,
    DATE_TRUNC('year', booking_date) as booking_year;

-- Extract components
SELECT 
    YEAR(booking_date) as year,
    MONTH(booking_date) as month,
    DAY(booking_date) as day,
    DAY_OF_WEEK(booking_date) as dow,
    DAY_OF_YEAR(booking_date) as doy;

String Functions
-- Concatenation
SELECT 
    guest_first_name || ' ' || guest_last_name as full_name,
    CONCAT(city, ', ', country) as location;

-- Case conversion
SELECT 
    UPPER(city) as city_upper,
    LOWER(email) as email_lower;

-- Substring
SELECT 
    SUBSTR(phone_number, 1, 3) as area_code,
    SUBSTRING(email, STRPOS(email, '@') + 1) as domain;

-- Replace
SELECT REPLACE(phone_number, '-', '') as clean_phone;

-- Trim
SELECT TRIM(city) as clean_city;

Conditional Logic
-- CASE statements
SELECT 
    booking_id,
    total_price,
    CASE 
        WHEN total_price < 100 THEN 'Budget'
        WHEN total_price < 300 THEN 'Mid-Range'
        WHEN total_price < 1000 THEN 'Premium'
        ELSE 'Luxury'
    END as price_category,
    CASE 
        WHEN nights_booked <= 3 THEN 'Short Stay'
        WHEN nights_booked <= 7 THEN 'Week Stay'
        ELSE 'Extended Stay'
    END as stay_type
FROM bookings;

-- COALESCE (return first non-null)
SELECT 
    listing_id,
    COALESCE(review_score, 0) as review_score_with_default;

-- NULLIF (return NULL if equal)
SELECT 
    listing_id,
    NULLIF(cancellation_count, 0) as cancellations;

Array and Map Functions
-- Array operations
SELECT 
    listing_id,
    amenities, -- assuming this is an array
    CARDINALITY(amenities) as amenity_count,
    CONTAINS(amenities, 'WiFi') as has_wifi,
    ARRAY_JOIN(amenities, ', ') as amenities_string;

-- Unnesting arrays
SELECT 
    listing_id,
    amenity
FROM listings
CROSS JOIN UNNEST(amenities) AS t(amenity);


8. COMPLEX ANALYTICS PATTERNS
Cohort Analysis
-- Monthly cohort retention
WITH first_booking AS (
    SELECT 
        guest_id,
        DATE_TRUNC('month', MIN(booking_date)) as cohort_month
    FROM bookings
    GROUP BY guest_id
),
booking_months AS (
    SELECT 
        b.guest_id,
        DATE_TRUNC('month', b.booking_date) as booking_month
    FROM bookings b
)
SELECT 
    fb.cohort_month,
    DATE_DIFF('month', fb.cohort_month, bm.booking_month) as months_since_first,
    COUNT(DISTINCT bm.guest_id) as active_users,
    COUNT(DISTINCT bm.guest_id) * 100.0 / COUNT(DISTINCT fb.guest_id) as retention_rate
FROM first_booking fb
LEFT JOIN booking_months bm ON fb.guest_id = bm.guest_id
GROUP BY fb.cohort_month, DATE_DIFF('month', fb.cohort_month, bm.booking_month)
ORDER BY fb.cohort_month, months_since_first;

Funnel Analysis
WITH funnel_steps AS (
    SELECT 
        session_id,
        MAX(CASE WHEN event_type = 'search' THEN 1 ELSE 0 END) as searched,
        MAX(CASE WHEN event_type = 'view_listing' THEN 1 ELSE 0 END) as viewed_listing,
        MAX(CASE WHEN event_type = 'start_booking' THEN 1 ELSE 0 END) as started_booking,
        MAX(CASE WHEN event_type = 'complete_booking' THEN 1 ELSE 0 END) as completed_booking
    FROM user_events
    WHERE event_date >= DATE '2024-01-01'
    GROUP BY session_id
)
SELECT 
    SUM(searched) as step1_search,
    SUM(viewed_listing) as step2_view,
    SUM(started_booking) as step3_start,
    SUM(completed_booking) as step4_complete,
    SUM(viewed_listing) * 100.0 / NULLIF(SUM(searched), 0) as search_to_view_rate,
    SUM(started_booking) * 100.0 / NULLIF(SUM(viewed_listing), 0) as view_to_start_rate,
    SUM(completed_booking) * 100.0 / NULLIF(SUM(started_booking), 0) as start_to_complete_rate
FROM funnel_steps;

Year-over-Year Growth
WITH monthly_metrics AS (
    SELECT 
        DATE_TRUNC('month', booking_date) as month,
        COUNT(*) as bookings,
        SUM(total_price) as revenue,
        COUNT(DISTINCT guest_id) as unique_guests
    FROM bookings
    GROUP BY DATE_TRUNC('month', booking_date)
)
SELECT 
    month,
    bookings,
    revenue,
    LAG(bookings, 12) OVER (ORDER BY month) as bookings_last_year,
    (bookings - LAG(bookings, 12) OVER (ORDER BY month)) * 100.0 / 
        NULLIF(LAG(bookings, 12) OVER (ORDER BY month), 0) as yoy_booking_growth,
    (revenue - LAG(revenue, 12) OVER (ORDER BY month)) * 100.0 / 
        NULLIF(LAG(revenue, 12) OVER (ORDER BY month), 0) as yoy_revenue_growth
FROM monthly_metrics
ORDER BY month;


9. OPTIMIZATION TIPS
Use CTEs for Readability
-- Common Table Expressions make complex queries readable
WITH active_listings AS (
    SELECT listing_id, city, property_type
    FROM listings
    WHERE status = 'active'
),
recent_bookings AS (
    SELECT 
        listing_id,
        COUNT(*) as booking_count,
        SUM(total_price) as revenue
    FROM bookings
    WHERE booking_date >= DATE '2024-01-01'
    GROUP BY listing_id
)
SELECT 
    al.city,
    al.property_type,
    COUNT(*) as listing_count,
    SUM(COALESCE(rb.booking_count, 0)) as total_bookings,
    SUM(COALESCE(rb.revenue, 0)) as total_revenue
FROM active_listings al
LEFT JOIN recent_bookings rb ON al.listing_id = rb.listing_id
GROUP BY al.city, al.property_type;

Filter Early
-- Push filters down to reduce data early
SELECT 
    l.city,
    COUNT(*) as bookings
FROM (
    SELECT listing_id, city
    FROM listings
    WHERE city IN ('San Francisco', 'New York')  -- Filter here
      AND status = 'active'
) l
INNER JOIN (
    SELECT listing_id, booking_date
    FROM bookings
    WHERE booking_date >= DATE '2024-01-01'  -- And here
) b ON l.listing_id = b.listing_id
GROUP BY l.city;


10. CASE STUDY PREPARATION
Product Metrics Framework
Key Questions to Ask:
What is the goal? (Increase bookings, revenue, user engagement?)
Who are the users? (Hosts, guests, both?)
What is the user journey? (Awareness → Search → Book → Stay → Review)
What are the constraints? (Time, resources, data availability)
Common Product Metrics for Airbnb
Acquisition Metrics:
New user sign-ups
Marketing channel effectiveness (CAC by channel)
Conversion rate (visitor → sign-up)
Activation Metrics:
Time to first search
Time to first booking
Completion rate of profile setup
Engagement Metrics:
Searches per user
Listings viewed per session
Booking frequency
Days between bookings
Retention Metrics:
D7, D30, D90 retention rates
Cohort retention curves
Churn rate
Revenue Metrics:
Gross Booking Value (GBV)
Average Daily Rate (ADR)
Occupancy rate
Revenue per available listing
Take rate (Airbnb's commission)
Quality Metrics:
Review scores
Response rate (hosts)
Cancellation rate
Support ticket volume
Analytical Approach Structure
Define the Problem


Restate the question
Clarify success metrics
Identify stakeholders
Hypothesize


What might be causing the issue?
What segments might behave differently?
Data Exploration


What data do we have?
What data do we need?
Are there data quality issues?
Analysis Plan


Break down into sub-questions
Prioritize analyses
Define success criteria
Generate Insights


What does the data tell us?
Are there surprising findings?
What are the limitations?
Recommend Actions


What should we do?
How do we measure success?
What are the risks?
Example Case Study Approach
Scenario: Bookings in City X dropped 15% month-over-month
Your Approach:
Clarify: Is this for all property types? All guest segments? Specific time period?


Segment the data:


-- Compare booking trends by segment
SELECT 
    property_type,
    guest_market,
    DATE_TRUNC('month', booking_date) as month,
    COUNT(*) as bookings,
    LAG(COUNT(*)) OVER (
        PARTITION BY property_type, guest_market 
        ORDER BY DATE_TRUNC('month', booking_date)
    ) as prev_month_bookings
FROM bookings
WHERE city = 'City X'
  AND booking_date >= DATE '2024-01-01'
GROUP BY property_type, guest_market, month;

Check funnel metrics: Did searches drop? View-to-book conversion?


External factors: Seasonality? Competition? Events?


Hypothesis-driven: Test specific theories with data



Airbnb SQL Interview Questions Guide
Table of Contents
Airbnb Database Schema
Basic SELECT Queries
Filtering and Conditional Logic
JOIN Operations
Aggregations and GROUP BY
Subqueries
Window Functions
Common Table Expressions (CTEs)
Data Modification
Advanced Airbnb Analytics

Airbnb Database Schema
Let's work with a simplified Airbnb database containing hosts, listings, bookings, guests, reviews, and searches:
-- Users table (both hosts and guests)
CREATE TABLE users (
    user_id INT PRIMARY KEY,
    email VARCHAR(100),
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    user_type VARCHAR(20), -- 'host', 'guest', 'both'
    created_at DATE,
    country VARCHAR(50),
    city VARCHAR(100),
    age INT,
    gender VARCHAR(10),
    is_superhost BOOLEAN,
    host_since DATE
);

-- Sample data
INSERT INTO users VALUES
(1, 'john.smith@email.com', 'John', 'Smith', 'both', '2018-01-15', 'USA', 'San Francisco', 35, 'M', true, '2018-06-01'),
(2, 'sarah.j@email.com', 'Sarah', 'Johnson', 'host', '2019-03-22', 'USA', 'Los Angeles', 42, 'F', true, '2019-03-22'),
(3, 'michael.b@email.com', 'Michael', 'Brown', 'guest', '2021-06-01', 'USA', 'New York', 28, 'M', false, NULL),
(4, 'emily.d@email.com', 'Emily', 'Davis', 'both', '2020-09-15', 'France', 'Paris', 31, 'F', false, '2021-01-10'),
(5, 'david.w@email.com', 'David', 'Wilson', 'host', '2018-02-01', 'UK', 'London', 45, 'M', true, '2018-02-01'),
(6, 'lisa.a@email.com', 'Lisa', 'Anderson', 'guest', '2019-07-10', 'USA', 'Chicago', 29, 'F', false, NULL),
(7, 'james.t@email.com', 'James', 'Taylor', 'host', '2017-05-15', 'Spain', 'Barcelona', 38, 'M', false, '2017-08-20'),
(8, 'jennifer.m@email.com', 'Jennifer', 'Martinez', 'guest', '2022-01-10', 'Mexico', 'Mexico City', 26, 'F', false, NULL),
(9, 'robert.l@email.com', 'Robert', 'Lee', 'guest', '2021-11-01', 'Canada', 'Toronto', 33, 'M', false, NULL),
(10, 'maria.g@email.com', 'Maria', 'Garcia', 'both', '2018-08-20', 'Italy', 'Rome', 37, 'F', true, '2019-01-15');

-- Listings table
CREATE TABLE listings (
    listing_id INT PRIMARY KEY,
    host_id INT,
    listing_type VARCHAR(50), -- 'entire_place', 'private_room', 'shared_room', 'hotel_room'
    property_type VARCHAR(50), -- 'apartment', 'house', 'condo', 'villa', 'loft'
    city VARCHAR(100),
    country VARCHAR(50),
    neighborhood VARCHAR(100),
    accommodates INT,
    bedrooms INT,
    bathrooms DECIMAL(3,1),
    price_per_night DECIMAL(10,2),
    cleaning_fee DECIMAL(10,2),
    minimum_nights INT,
    maximum_nights INT,
    instant_bookable BOOLEAN,
    is_business_travel_ready BOOLEAN,
    created_at DATE,
    latitude DECIMAL(10,8),
    longitude DECIMAL(11,8)
);

INSERT INTO listings VALUES
(1, 1, 'entire_place', 'apartment', 'San Francisco', 'USA', 'SOMA', 4, 2, 1.5, 250, 100, 2, 30, true, true, '2018-06-15', 37.7749, -122.4194),
(2, 1, 'entire_place', 'condo', 'San Francisco', 'USA', 'Marina', 2, 1, 1.0, 180, 75, 3, 14, true, false, '2019-02-10', 37.8044, -122.4324),
(3, 2, 'private_room', 'house', 'Los Angeles', 'USA', 'Venice', 2, 1, 1.0, 85, 30, 1, 365, true, false, '2019-04-01', 33.9850, -118.4695),
(4, 2, 'entire_place', 'apartment', 'Los Angeles', 'USA', 'Hollywood', 6, 3, 2.0, 350, 150, 2, 60, false, true, '2020-01-15', 34.0928, -118.3287),
(5, 4, 'entire_place', 'apartment', 'Paris', 'France', 'Marais', 4, 2, 1.0, 300, 80, 3, 90, true, true, '2021-01-20', 48.8566, 2.3522),
(6, 5, 'private_room', 'apartment', 'London', 'UK', 'Camden', 2, 1, 0.5, 75, 25, 2, 30, false, false, '2018-03-01', 51.5074, -0.1278),
(7, 5, 'entire_place', 'house', 'London', 'UK', 'Notting Hill', 8, 4, 3.0, 500, 200, 3, 21, true, true, '2018-08-15', 51.5113, -0.2052),
(8, 7, 'entire_place', 'villa', 'Barcelona', 'Spain', 'Eixample', 10, 5, 4.0, 600, 250, 5, 14, false, true, '2017-09-01', 41.3851, 2.1734),
(9, 10, 'private_room', 'apartment', 'Rome', 'Italy', 'Trastevere', 2, 1, 1.0, 90, 30, 1, 180, true, false, '2019-02-01', 41.9028, 12.4964),
(10, 10, 'entire_place', 'condo', 'Rome', 'Italy', 'Centro Storico', 4, 2, 2.0, 280, 100, 2, 30, true, true, '2019-06-15', 41.8986, 12.4768);

-- Bookings table
CREATE TABLE bookings (
    booking_id INT PRIMARY KEY,
    listing_id INT,
    guest_id INT,
    check_in_date DATE,
    check_out_date DATE,
    booking_date DATE,
    number_of_guests INT,
    total_price DECIMAL(10,2),
    booking_status VARCHAR(20), -- 'confirmed', 'cancelled', 'completed'
    cancellation_date DATE,
    payment_method VARCHAR(30), -- 'credit_card', 'paypal', 'apple_pay'
    is_business_travel BOOLEAN
);

INSERT INTO bookings VALUES
(1, 1, 3, '2023-06-15', '2023-06-18', '2023-05-01', 2, 850, 'completed', NULL, 'credit_card', false),
(2, 1, 6, '2023-07-01', '2023-07-05', '2023-06-15', 3, 1200, 'completed', NULL, 'paypal', true),
(3, 2, 3, '2023-08-10', '2023-08-13', '2023-07-20', 2, 615, 'completed', NULL, 'credit_card', false),
(4, 3, 8, '2023-06-01', '2023-06-07', '2023-05-15', 1, 540, 'completed', NULL, 'apple_pay', false),
(5, 4, 9, '2023-07-15', '2023-07-20', '2023-06-01', 4, 1900, 'cancelled', '2023-07-10', 'credit_card', false),
(6, 5, 3, '2023-08-01', '2023-08-08', '2023-06-15', 3, 2180, 'completed', NULL, 'credit_card', false),
(7, 6, 8, '2023-09-01', '2023-09-04', '2023-08-15', 1, 250, 'completed', NULL, 'paypal', false),
(8, 7, 6, '2023-09-10', '2023-09-17', '2023-08-01', 6, 3700, 'completed', NULL, 'credit_card', true),
(9, 8, 3, '2023-07-01', '2023-07-10', '2023-05-20', 8, 5650, 'completed', NULL, 'credit_card', false),
(10, 1, 9, '2023-09-20', '2023-09-25', '2023-08-30', 2, 1350, 'confirmed', NULL, 'apple_pay', false);

-- Reviews table
CREATE TABLE reviews (
    review_id INT PRIMARY KEY,
    booking_id INT,
    reviewer_id INT,
    reviewee_id INT,
    review_type VARCHAR(20), -- 'guest_to_host', 'host_to_guest'
    overall_rating INT, -- 1-5
    cleanliness_rating INT,
    communication_rating INT,
    checkin_rating INT,
    accuracy_rating INT,
    location_rating INT,
    value_rating INT,
    review_text TEXT,
    review_date DATE
);

INSERT INTO reviews VALUES
(1, 1, 3, 1, 'guest_to_host', 5, 5, 5, 5, 5, 5, 4, 'Amazing place in SOMA! Very clean and convenient.', '2023-06-20'),
(2, 1, 1, 3, 'host_to_guest', 5, NULL, 5, NULL, NULL, NULL, NULL, 'Great guest, very respectful!', '2023-06-20'),
(3, 2, 6, 1, 'guest_to_host', 4, 4, 5, 5, 4, 5, 4, 'Good location for business travel. Minor cleanliness issues.', '2023-07-08'),
(4, 3, 3, 1, 'guest_to_host', 5, 5, 5, 5, 5, 5, 5, 'Perfect Marina location! Will book again.', '2023-08-15'),
(5, 4, 8, 2, 'guest_to_host', 5, 5, 5, 4, 5, 5, 5, 'Lovely room in Venice. Great host!', '2023-06-10'),
(6, 6, 3, 4, 'guest_to_host', 5, 5, 5, 5, 5, 5, 5, 'Incredible Paris apartment! Location was perfect.', '2023-08-10'),
(7, 7, 8, 5, 'guest_to_host', 3, 3, 4, 3, 4, 4, 3, 'Room was smaller than expected, but good location.', '2023-09-06'),
(8, 8, 6, 5, 'guest_to_host', 5, 5, 5, 5, 5, 5, 5, 'Beautiful Notting Hill house! Perfect for our team.', '2023-09-20'),
(9, 9, 3, 7, 'guest_to_host', 5, 5, 5, 5, 5, 5, 5, 'Stunning villa in Barcelona! Exceeded expectations.', '2023-07-12');

-- Search logs table
CREATE TABLE search_logs (
    search_id INT PRIMARY KEY,
    user_id INT,
    search_date DATETIME,
    check_in_date DATE,
    check_out_date DATE,
    destination_city VARCHAR(100),
    number_of_guests INT,
    min_price DECIMAL(10,2),
    max_price DECIMAL(10,2),
    filter_wifi BOOLEAN,
    filter_parking BOOLEAN,
    filter_instant_book BOOLEAN,
    filter_superhost BOOLEAN,
    search_result_count INT,
    clicked_listing_ids VARCHAR(200), -- comma-separated listing IDs
    booked_listing_id INT
);

INSERT INTO search_logs VALUES
(1, 3, '2023-05-01 10:30:00', '2023-06-15', '2023-06-18', 'San Francisco', 2, 100, 300, true, false, true, false, 25, '1,2,5', 1),
(2, 3, '2023-05-01 10:45:00', '2023-06-15', '2023-06-18', 'San Francisco', 2, 150, 400, true, false, true, true, 12, '1', 1),
(3, 6, '2023-06-15 14:20:00', '2023-07-01', '2023-07-05', 'San Francisco', 3, 100, 350, true, true, false, false, 18, '1,2,4', 1),
(4, 8, '2023-05-15 09:00:00', '2023-06-01', '2023-06-07', 'Los Angeles', 1, 50, 150, false, false, true, false, 42, '3,4', 3),
(5, 3, '2023-06-15 16:30:00', '2023-08-01', '2023-08-08', 'Paris', 3, 200, 500, true, false, true, false, 8, '5', 5),
(6, 9, '2023-08-30 11:00:00', '2023-09-20', '2023-09-25', 'San Francisco', 2, 150, 300, true, true, true, true, 5, '1,2', 1);

-- Host calendar (availability and pricing)
CREATE TABLE calendar (
    listing_id INT,
    date DATE,
    available BOOLEAN,
    price DECIMAL(10,2),
    minimum_nights INT,
    maximum_nights INT,
    PRIMARY KEY (listing_id, date)
);

-- Sample calendar data for listing 1
INSERT INTO calendar VALUES
(1, '2023-10-01', true, 250, 2, 30),
(1, '2023-10-02', true, 250, 2, 30),
(1, '2023-10-03', true, 250, 2, 30),
(1, '2023-10-04', false, 250, 2, 30),
(1, '2023-10-05', false, 250, 2, 30),
(1, '2023-10-06', true, 300, 2, 30), -- weekend pricing
(1, '2023-10-07', true, 300, 2, 30),
(1, '2023-10-08', true, 250, 2, 30),
(1, '2023-10-09', true, 250, 2, 30),
(1, '2023-10-10', true, 250, 2, 30);


Basic SELECT Queries
Question 1: Basic listing information
Question: Retrieve all Airbnb listings in San Francisco.
Answer:
SELECT * 
FROM listings
WHERE city = 'San Francisco';

Question 2: Host information with listings
Question: Get host names and their listing counts.
Answer:
SELECT 
    u.first_name,
    u.last_name,
    u.is_superhost,
    COUNT(l.listing_id) as total_listings
FROM users u
LEFT JOIN listings l ON u.user_id = l.host_id
WHERE u.user_type IN ('host', 'both')
GROUP BY u.user_id, u.first_name, u.last_name, u.is_superhost
ORDER BY total_listings DESC;

Question 3: Price calculations
Question: Display listings with their total first-night cost (including cleaning fee).
Answer:
SELECT 
    listing_id,
    city,
    listing_type,
    price_per_night,
    cleaning_fee,
    price_per_night + cleaning_fee AS first_night_total,
    price_per_night * 7 + cleaning_fee AS weekly_total
FROM listings
ORDER BY first_night_total DESC;

Question 4: Finding unique property types
Question: What types of properties are available on Airbnb?
Answer:
SELECT DISTINCT 
    property_type,
    COUNT(*) as count
FROM listings
GROUP BY property_type
ORDER BY count DESC;


Filtering and Conditional Logic
Question 5: Price range filtering
Question: Find affordable listings (under $100/night) that can accommodate at least 2 guests.
Answer:
SELECT 
    listing_id,
    city,
    listing_type,
    price_per_night,
    accommodates
FROM listings
WHERE price_per_night < 100 
  AND accommodates >= 2
ORDER BY price_per_night;

Question 6: Superhost listings
Question: Find all listings owned by superhosts in Europe.
Answer:
SELECT 
    l.*,
    u.first_name,
    u.last_name
FROM listings l
INNER JOIN users u ON l.host_id = u.user_id
WHERE u.is_superhost = true
  AND l.country IN ('France', 'Italy', 'Spain', 'UK')
ORDER BY l.country, l.city;

Question 7: Business travel ready
Question: Find entire place listings that are business travel ready and instant bookable.
Answer:
SELECT 
    listing_id,
    city,
    price_per_night,
    accommodates
FROM listings
WHERE listing_type = 'entire_place'
  AND is_business_travel_ready = true
  AND instant_bookable = true
  AND minimum_nights <= 3
ORDER BY price_per_night;

Question 8: Booking status analysis
Question: Categorize bookings by their status and calculate revenue impact.
Answer:
SELECT 
    booking_status,
    COUNT(*) as booking_count,
    SUM(total_price) as total_revenue,
    AVG(total_price) as avg_booking_value,
    SUM(CASE WHEN booking_status = 'cancelled' THEN total_price ELSE 0 END) as lost_revenue
FROM bookings
GROUP BY booking_status;

Question 9: Guest booking patterns
Question: Identify guests who have made multiple bookings.
Answer:
SELECT 
    u.first_name,
    u.last_name,
    COUNT(b.booking_id) as total_bookings,
    SUM(b.total_price) as total_spent,
    AVG(b.total_price) as avg_booking_value
FROM users u
INNER JOIN bookings b ON u.user_id = b.guest_id
GROUP BY u.user_id, u.first_name, u.last_name
HAVING COUNT(b.booking_id) >= 2
ORDER BY total_bookings DESC;

Question 10: Dynamic pricing analysis
Question: Categorize listings by their pricing tier and location.
Answer:
SELECT 
    city,
    CASE 
        WHEN price_per_night < 75 THEN 'Budget'
        WHEN price_per_night BETWEEN 75 AND 150 THEN 'Mid-range'
        WHEN price_per_night BETWEEN 151 AND 300 THEN 'Premium'
        ELSE 'Luxury'
    END AS price_tier,
    COUNT(*) as listing_count,
    AVG(price_per_night) as avg_price
FROM listings
GROUP BY city, price_tier
ORDER BY city, avg_price;


JOIN Operations
Question 11: Host and listing details
Question: Show detailed information about hosts and all their listings.
Answer:
SELECT 
    u.first_name + ' ' + u.last_name AS host_name,
    u.is_superhost,
    DATEDIFF(CURRENT_DATE, u.host_since) / 365.0 AS years_hosting,
    l.listing_type,
    l.property_type,
    l.city,
    l.price_per_night
FROM users u
INNER JOIN listings l ON u.user_id = l.host_id
WHERE u.user_type IN ('host', 'both')
ORDER BY u.user_id, l.price_per_night DESC;

Question 12: Booking and guest information
Question: Get complete booking details with guest information.
Answer:
SELECT 
    b.booking_id,
    u.first_name + ' ' + u.last_name AS guest_name,
    u.country AS guest_country,
    l.city AS destination_city,
    b.check_in_date,
    b.check_out_date,
    DATEDIFF(b.check_out_date, b.check_in_date) AS nights_stayed,
    b.total_price,
    b.booking_status
FROM bookings b
INNER JOIN users u ON b.guest_id = u.user_id
INNER JOIN listings l ON b.listing_id = l.listing_id
ORDER BY b.check_in_date DESC;

Question 13: Reviews with booking context
Question: Join reviews with their associated bookings and listings.
Answer:
SELECT 
    l.city,
    l.listing_type,
    r.overall_rating,
    r.cleanliness_rating,
    r.value_rating,
    r.review_text,
    u_guest.first_name AS guest_name,
    u_host.first_name AS host_name
FROM reviews r
INNER JOIN bookings b ON r.booking_id = b.booking_id
INNER JOIN listings l ON b.listing_id = l.listing_id
INNER JOIN users u_guest ON r.reviewer_id = u_guest.user_id
INNER JOIN users u_host ON r.reviewee_id = u_host.user_id
WHERE r.review_type = 'guest_to_host'
ORDER BY r.overall_rating DESC;

Question 14: Search to booking conversion
Question: Track user journey from search to booking.
Answer:
SELECT 
    s.user_id,
    u.first_name,
    s.destination_city,
    s.search_date,
    s.clicked_listing_ids,
    s.booked_listing_id,
    b.booking_date,
    b.total_price,
    DATEDIFF(b.booking_date, s.search_date) AS days_to_book
FROM search_logs s
INNER JOIN users u ON s.user_id = u.user_id
LEFT JOIN bookings b ON s.user_id = b.guest_id 
    AND s.booked_listing_id = b.listing_id
    AND b.booking_date >= s.search_date
WHERE s.booked_listing_id IS NOT NULL
ORDER BY s.search_date;

Question 15: Calendar availability analysis
Question: Find available dates for listings with their adjusted weekend pricing.
Answer:
SELECT 
    l.listing_id,
    l.city,
    l.listing_type,
    c.date,
    c.available,
    l.price_per_night AS base_price,
    c.price AS calendar_price,
    c.price - l.price_per_night AS price_adjustment
FROM listings l
INNER JOIN calendar c ON l.listing_id = c.listing_id
WHERE c.available = true
  AND c.date BETWEEN '2023-10-01' AND '2023-10-10'
ORDER BY l.listing_id, c.date;


Aggregations and GROUP BY
Question 16: City-level metrics
Question: Calculate average prices and availability by city.
Answer:
SELECT 
    city,
    country,
    COUNT(*) AS total_listings,
    AVG(price_per_night) AS avg_price,
    MIN(price_per_night) AS min_price,
    MAX(price_per_night) AS max_price,
    AVG(accommodates) AS avg_capacity,
    SUM(CASE WHEN instant_bookable = true THEN 1 ELSE 0 END) AS instant_bookable_count
FROM listings
GROUP BY city, country
ORDER BY total_listings DESC;

Question 17: Host performance metrics
Question: Calculate key metrics for each host.
Answer:
SELECT 
    u.user_id,
    u.first_name,
    u.last_name,
    u.is_superhost,
    COUNT(DISTINCT l.listing_id) AS total_listings,
    COUNT(DISTINCT b.booking_id) AS total_bookings,
    SUM(b.total_price) AS total_revenue,
    AVG(r.overall_rating) AS avg_rating
FROM users u
LEFT JOIN listings l ON u.user_id = l.host_id
LEFT JOIN bookings b ON l.listing_id = b.listing_id AND b.booking_status = 'completed'
LEFT JOIN reviews r ON b.booking_id = r.booking_id AND r.review_type = 'guest_to_host'
WHERE u.user_type IN ('host', 'both')
GROUP BY u.user_id, u.first_name, u.last_name, u.is_superhost
HAVING COUNT(DISTINCT l.listing_id) > 0
ORDER BY total_revenue DESC;

Question 18: Seasonal booking patterns
Question: Analyze booking patterns by month.
Answer:
SELECT 
    DATE_FORMAT(check_in_date, '%Y-%m') AS month,
    COUNT(*) AS total_bookings,
    SUM(CASE WHEN booking_status = 'completed' THEN 1 ELSE 0 END) AS completed_bookings,
    SUM(CASE WHEN booking_status = 'cancelled' THEN 1 ELSE 0 END) AS cancelled_bookings,
    ROUND(100.0 * SUM(CASE WHEN booking_status = 'cancelled' THEN 1 ELSE 0 END) / COUNT(*), 2) AS cancellation_rate,
    AVG(total_price) AS avg_booking_value,
    AVG(DATEDIFF(check_out_date, check_in_date)) AS avg_length_of_stay
FROM bookings
GROUP BY DATE_FORMAT(check_in_date, '%Y-%m')
ORDER BY month;

Question 19: Property type profitability
Question: Which property types generate the most revenue?
Answer:
SELECT 
    l.property_type,
    l.listing_type,
    COUNT(DISTINCT l.listing_id) AS listing_count,
    COUNT(b.booking_id) AS booking_count,
    SUM(b.total_price) AS total_revenue,
    AVG(b.total_price) AS avg_booking_value,
    SUM(b.total_price) / COUNT(DISTINCT l.listing_id) AS revenue_per_listing
FROM listings l
LEFT JOIN bookings b ON l.listing_id = b.listing_id 
    AND b.booking_status = 'completed'
GROUP BY l.property_type, l.listing_type
HAVING COUNT(b.booking_id) > 0
ORDER BY total_revenue DESC;

Question 20: Review score distribution
Question: Analyze the distribution of review scores by category.
Answer:
SELECT 
    overall_rating,
    COUNT(*) AS review_count,
    ROUND(100.0 * COUNT(*) / SUM(COUNT(*)) OVER (), 2) AS percentage,
    AVG(cleanliness_rating) AS avg_cleanliness,
    AVG(communication_rating) AS avg_communication,
    AVG(value_rating) AS avg_value
FROM reviews
WHERE review_type = 'guest_to_host'
GROUP BY overall_rating
ORDER BY overall_rating DESC;


Subqueries
Question 21: Above-average performers
Question: Find listings that perform better than city average.
Answer:
SELECT 
    l.listing_id,
    l.city,
    l.price_per_night,
    city_avg.avg_city_price,
    l.price_per_night - city_avg.avg_city_price AS price_diff
FROM listings l
INNER JOIN (
    SELECT city, AVG(price_per_night) AS avg_city_price
    FROM listings
    GROUP BY city
) city_avg ON l.city = city_avg.city
WHERE l.price_per_night > city_avg.avg_city_price
ORDER BY price_diff DESC;

Question 22: High-value guests
Question: Identify guests who spend more than the average booking value.
Answer:
SELECT 
    u.first_name,
    u.last_name,
    COUNT(b.booking_id) AS bookings,
    AVG(b.total_price) AS avg_spend
FROM users u
INNER JOIN bookings b ON u.user_id = b.guest_id
WHERE b.booking_status = 'completed'
GROUP BY u.user_id, u.first_name, u.last_name
HAVING AVG(b.total_price) > (
    SELECT AVG(total_price) 
    FROM bookings 
    WHERE booking_status = 'completed'
)
ORDER BY avg_spend DESC;

Question 23: Listings without bookings
Question: Find listings that haven't received any bookings.
Answer:
SELECT 
    l.listing_id,
    l.city,
    l.price_per_night,
    l.created_at,
    DATEDIFF(CURRENT_DATE, l.created_at) AS days_since_listing
FROM listings l
WHERE NOT EXISTS (
    SELECT 1 
    FROM bookings b 
    WHERE b.listing_id = l.listing_id
)
ORDER BY days_since_listing DESC;

Question 24: Search effectiveness
Question: Find searches that resulted in bookings vs those that didn't.
Answer:
WITH search_conversions AS (
    SELECT 
        destination_city,
        COUNT(*) AS total_searches,
        SUM(CASE WHEN booked_listing_id IS NOT NULL THEN 1 ELSE 0 END) AS converted_searches
    FROM search_logs
    GROUP BY destination_city
)
SELECT 
    destination_city,
    total_searches,
    converted_searches,
    ROUND(100.0 * converted_searches / total_searches, 2) AS conversion_rate
FROM search_conversions
WHERE total_searches >= 2
ORDER BY conversion_rate DESC;

Question 25: Competitive pricing analysis
Question: Find listings priced competitively within their neighborhood.
Answer:
SELECT 
    l1.listing_id,
    l1.neighborhood,
    l1.price_per_night,
    (
        SELECT AVG(l2.price_per_night)
        FROM listings l2
        WHERE l2.neighborhood = l1.neighborhood
          AND l2.listing_type = l1.listing_type
    ) AS neighborhood_avg,
    (
        SELECT COUNT(*)
        FROM listings l2
        WHERE l2.neighborhood = l1.neighborhood
          AND l2.price_per_night < l1.price_per_night
    ) + 1 AS price_rank_in_neighborhood
FROM listings l1
WHERE l1.city = 'San Francisco'
ORDER BY l1.neighborhood, price_rank_in_neighborhood;


Window Functions
Question 26: Ranking hosts by revenue
Question: Rank hosts by their total revenue using window functions.
Answer:
WITH host_revenue AS (
    SELECT 
        l.host_id,
        u.first_name,
        u.last_name,
        u.is_superhost,
        SUM(b.total_price) AS total_revenue
    FROM listings l
    INNER JOIN bookings b ON l.listing_id = b.listing_id
    INNER JOIN users u ON l.host_id = u.user_id
    WHERE b.booking_status = 'completed'
    GROUP BY l.host_id, u.first_name, u.last_name, u.is_superhost
)
SELECT 
    first_name,
    last_name,
    is_superhost,
    total_revenue,
    RANK() OVER (ORDER BY total_revenue DESC) AS revenue_rank,
    DENSE_RANK() OVER (ORDER BY total_revenue DESC) AS revenue_dense_rank,
    NTILE(4) OVER (ORDER BY total_revenue DESC) AS revenue_quartile
FROM host_revenue
ORDER BY revenue_rank;

Question 27: Booking trends over time
Question: Calculate running totals and moving averages for bookings.
Answer:
SELECT 
    DATE(booking_date) AS booking_day,
    COUNT(*) AS daily_bookings,
    SUM(total_price) AS daily_revenue,
    SUM(COUNT(*)) OVER (ORDER BY DATE(booking_date)) AS cumulative_bookings,
    SUM(SUM(total_price)) OVER (ORDER BY DATE(booking_date)) AS cumulative_revenue,
    AVG(SUM(total_price)) OVER (
        ORDER BY DATE(booking_date) 
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) AS seven_day_avg_revenue
FROM bookings
WHERE booking_status = 'completed'
GROUP BY DATE(booking_date)
ORDER BY booking_day;

Question 28: Price positioning analysis
Question: Analyze how each listing's price compares to others in the same city.
Answer:
SELECT 
    listing_id,
    city,
    price_per_night,
    AVG(price_per_night) OVER (PARTITION BY city) AS city_avg_price,
    MIN(price_per_night) OVER (PARTITION BY city) AS city_min_price,
    MAX(price_per_night) OVER (PARTITION BY city) AS city_max_price,
    PERCENT_RANK() OVER (PARTITION BY city ORDER BY price_per_night) AS price_percentile,
    ROW_NUMBER() OVER (PARTITION BY city ORDER BY price_per_night DESC) AS price_rank_desc
FROM listings
ORDER BY city, price_per_night DESC;

Question 29: Guest booking frequency
Question: Analyze the time between bookings for repeat guests.
Answer:
WITH guest_bookings AS (
    SELECT 
        guest_id,
        booking_date,
        total_price,
        LAG(booking_date) OVER (PARTITION BY guest_id ORDER BY booking_date) AS previous_booking_date,
        LEAD(booking_date) OVER (PARTITION BY guest_id ORDER BY booking_date) AS next_booking_date
    FROM bookings
    WHERE booking_status = 'completed'
)
SELECT 
    guest_id,
    booking_date,
    previous_booking_date,
    DATEDIFF(booking_date, previous_booking_date) AS days_since_last_booking,
    DATEDIFF(next_booking_date, booking_date) AS days_to_next_booking,
    total_price
FROM guest_bookings
WHERE previous_booking_date IS NOT NULL
ORDER BY guest_id, booking_date;

Question 30: Review score trends
Question: Track review score trends over time for each listing.
Answer:
WITH listing_reviews AS (
    SELECT 
        l.listing_id,
        l.city,
        r.review_date,
        r.overall_rating,
        AVG(r.overall_rating) OVER (
            PARTITION BY l.listing_id 
            ORDER BY r.review_date 
            ROWS BETWEEN 4 PRECEDING AND CURRENT ROW
        ) AS rolling_avg_rating,
        ROW_NUMBER() OVER (PARTITION BY l.listing_id ORDER BY r.review_date DESC) AS review_recency
    FROM reviews r
    INNER JOIN bookings b ON r.booking_id = b.booking_id
    INNER JOIN listings l ON b.listing_id = l.listing_id
    WHERE r.review_type = 'guest_to_host'
)
SELECT 
    listing_id,
    city,
    review_date,
    overall_rating,
    ROUND(rolling_avg_rating, 2) AS five_review_avg,
    review_recency
FROM listing_reviews
WHERE review_recency <= 10
ORDER BY listing_id, review_date DESC;


Common Table Expressions (CTEs)
Question 31: Host lifetime value calculation
Question: Calculate comprehensive lifetime value metrics for hosts.
Answer:
WITH host_metrics AS (
    SELECT 
        l.host_id,
        COUNT(DISTINCT l.listing_id) AS listing_count,
        MIN(l.created_at) AS first_listing_date,
        COUNT(DISTINCT b.booking_id) AS total_bookings,
        SUM(b.total_price) AS lifetime_revenue
    FROM listings l
    LEFT JOIN bookings b ON l.listing_id = b.listing_id 
        AND b.booking_status = 'completed'
    GROUP BY l.host_id
),
host_ratings AS (
    SELECT 
        l.host_id,
        AVG(r.overall_rating) AS avg_rating,
        COUNT(r.review_id) AS review_count
    FROM listings l
    INNER JOIN bookings b ON l.listing_id = b.listing_id
    INNER JOIN reviews r ON b.booking_id = r.booking_id
    WHERE r.review_type = 'guest_to_host'
    GROUP BY l.host_id
)
SELECT 
    u.first_name,
    u.last_name,
    u.is_superhost,
    hm.listing_count,
    hm.total_bookings,
    hm.lifetime_revenue,
    hm.lifetime_revenue / NULLIF(hm.listing_count, 0) AS revenue_per_listing,
    hr.avg_rating,
    hr.review_count,
    DATEDIFF(CURRENT_DATE, hm.first_listing_date) AS days_as_host
FROM users u
INNER JOIN host_metrics hm ON u.user_id = hm.host_id
LEFT JOIN host_ratings hr ON u.user_id = hr.host_id
WHERE u.user_type IN ('host', 'both')
ORDER BY hm.lifetime_revenue DESC;

Question 32: Market saturation analysis
Question: Analyze market saturation and opportunity by city.
Answer:
WITH city_supply AS (
    SELECT 
        city,
        COUNT(*) AS total_listings,
        SUM(accommodates) AS total_capacity,
        AVG(price_per_night) AS avg_price
    FROM listings
    GROUP BY city
),
city_demand AS (
    SELECT 
        l.city,
        COUNT(DISTINCT b.booking_id) AS total_bookings,
        SUM(b.number_of_guests) AS total_guests,
        AVG(DATEDIFF(b.check_out_date, b.check_in_date)) AS avg_stay_length
    FROM bookings b
    INNER JOIN listings l ON b.listing_id = l.listing_id
    WHERE b.booking_status = 'completed'
    GROUP BY l.city
),
city_performance AS (
    SELECT 
        l.city,
        AVG(r.overall_rating) AS avg_rating,
        COUNT(DISTINCT r.review_id) AS total_reviews
    FROM reviews r
    INNER JOIN bookings b ON r.booking_id = b.booking_id
    INNER JOIN listings l ON b.listing_id = l.listing_id
    WHERE r.review_type = 'guest_to_host'
    GROUP BY l.city
)
SELECT 
    cs.city,
    cs.total_listings,
    cs.avg_price,
    cd.total_bookings,
    ROUND(cd.total_bookings * 1.0 / cs.total_listings, 2) AS bookings_per_listing,
    cd.avg_stay_length,
    cp.avg_rating,
    CASE 
        WHEN cd.total_bookings * 1.0 / cs.total_listings > 10 THEN 'High Demand'
        WHEN cd.total_bookings * 1.0 / cs.total_listings > 5 THEN 'Moderate Demand'
        ELSE 'Low Demand'
    END AS market_status
FROM city_supply cs
LEFT JOIN city_demand cd ON cs.city = cd.city
LEFT JOIN city_performance cp ON cs.city = cp.city
ORDER BY bookings_per_listing DESC;

Question 33: Guest segmentation
Question: Segment guests based on their booking behavior.
Answer:
WITH guest_summary AS (
    SELECT 
        u.user_id,
        u.first_name,
        u.last_name,
        u.country,
        COUNT(b.booking_id) AS booking_count,
        SUM(b.total_price) AS total_spent,
        AVG(b.total_price) AS avg_booking_value,
        MIN(b.booking_date) AS first_booking,
        MAX(b.booking_date) AS last_booking,
        SUM(CASE WHEN b.is_business_travel = true THEN 1 ELSE 0 END) AS business_trips
    FROM users u
    INNER JOIN bookings b ON u.user_id = b.guest_id
    WHERE b.booking_status = 'completed'
    GROUP BY u.user_id, u.first_name, u.last_name, u.country
),
guest_segments AS (
    SELECT 
        *,
        CASE 
            WHEN booking_count >= 5 AND avg_booking_value > 500 THEN 'VIP'
            WHEN booking_count >= 3 OR total_spent > 2000 THEN 'Frequent Traveler'
            WHEN business_trips > 0 THEN 'Business Traveler'
            WHEN booking_count = 1 THEN 'New Guest'
            ELSE 'Occasional Traveler'
        END AS guest_segment,
        DATEDIFF(CURRENT_DATE, last_booking) AS days_since_last_booking
    FROM guest_summary
)
SELECT 
    guest_segment,
    COUNT(*) AS segment_size,
    AVG(booking_count) AS avg_bookings,
    AVG(total_spent) AS avg_lifetime_value,
    AVG(avg_booking_value) AS avg_booking_size,
    AVG(days_since_last_booking) AS avg_recency
FROM guest_segments
GROUP BY guest_segment
ORDER BY avg_lifetime_value DESC;


Data Modification
Question 34: Update pricing strategy
Question: Implement dynamic pricing - increase weekend prices by 20%.
Answer:
-- Update calendar prices for weekends
UPDATE calendar c
SET c.price = c.price * 1.20
WHERE DAYOFWEEK(c.date) IN (1, 7) -- Sunday = 1, Saturday = 7
  AND c.date >= CURRENT_DATE;

-- Alternative: Update base prices for listings based on performance
UPDATE listings l
SET l.price_per_night = l.price_per_night * 
    CASE 
        WHEN (SELECT AVG(overall_rating) 
              FROM reviews r 
              INNER JOIN bookings b ON r.booking_id = b.booking_id
              WHERE b.listing_id = l.listing_id) >= 4.5 
        THEN 1.10
        ELSE 1.0
    END
WHERE l.listing_id IN (
    SELECT DISTINCT listing_id 
    FROM bookings 
    WHERE booking_status = 'completed'
);

Question 35: Deactivate underperforming listings
Question: Mark listings as inactive if they haven't been booked in 6 months.
Answer:
-- Add inactive flag to listings without recent bookings
ALTER TABLE listings ADD COLUMN is_active BOOLEAN DEFAULT true;

UPDATE listings l
SET is_active = false
WHERE NOT EXISTS (
    SELECT 1
    FROM bookings b
    WHERE b.listing_id = l.listing_id
      AND b.booking_date >= DATE_SUB(CURRENT_DATE, INTERVAL 6 MONTH)
      AND b.booking_status IN ('completed', 'confirmed')
);

Question 36: Guest loyalty program
Question: Create a loyalty tier system based on booking history.
Answer:
-- Create loyalty table
CREATE TABLE guest_loyalty AS
WITH guest_tiers AS (
    SELECT 
        guest_id,
        COUNT(*) AS total_bookings,
        SUM(total_price) AS lifetime_value,
        CASE 
            WHEN COUNT(*) >= 10 OR SUM(total_price) >= 10000 THEN 'Platinum'
            WHEN COUNT(*) >= 5 OR SUM(total_price) >= 5000 THEN 'Gold'
            WHEN COUNT(*) >= 2 OR SUM(total_price) >= 1000 THEN 'Silver'
            ELSE 'Bronze'
        END AS loyalty_tier,
        CURRENT_DATE AS tier_assigned_date
    FROM bookings
    WHERE booking_status = 'completed'
    GROUP BY guest_id
)
SELECT * FROM guest_tiers;

-- Apply discounts based on loyalty tier
ALTER TABLE bookings ADD COLUMN loyalty_discount DECIMAL(5,2) DEFAULT 0;

UPDATE bookings b
SET loyalty_discount = 
    CASE 
        WHEN gl.loyalty_tier = 'Platinum' THEN b.total_price * 0.15
        WHEN gl.loyalty_tier = 'Gold' THEN b.total_price * 0.10
        WHEN gl.loyalty_tier = 'Silver' THEN b.total_price * 0.05
        ELSE 0
    END
FROM guest_loyalty gl
WHERE b.guest_id = gl.guest_id
  AND b.booking_date >= gl.tier_assigned_date;


Advanced Airbnb Analytics
Question 37: Cohort retention analysis
Question: Analyze guest retention by signup cohort.
Answer:
WITH cohort_data AS (
    SELECT 
        u.user_id,
        DATE_FORMAT(u.created_at, '%Y-%m') AS cohort_month,
        DATE_FORMAT(b.booking_date, '%Y-%m') AS booking_month,
        PERIOD_DIFF(
            DATE_FORMAT(b.booking_date, '%Y%m'),
            DATE_FORMAT(u.created_at, '%Y%m')
        ) AS months_since_signup
    FROM users u
    INNER JOIN bookings b ON u.user_id = b.guest_id
    WHERE b.booking_status = 'completed'
),
cohort_size AS (
    SELECT 
        cohort_month,
        COUNT(DISTINCT user_id) AS cohort_users
    FROM cohort_data
    WHERE months_since_signup = 0
    GROUP BY cohort_month
),
retention_data AS (
    SELECT 
        cohort_month,
        months_since_signup,
        COUNT(DISTINCT user_id) AS retained_users
    FROM cohort_data
    GROUP BY cohort_month, months_since_signup
)
SELECT 
    r.cohort_month,
    r.months_since_signup,
    c.cohort_users,
    r.retained_users,
    ROUND(100.0 * r.retained_users / c.cohort_users, 2) AS retention_rate
FROM retention_data r
INNER JOIN cohort_size c ON r.cohort_month = c.cohort_month
WHERE r.months_since_signup <= 6
ORDER BY r.cohort_month, r.months_since_signup;

Question 38: Search funnel analysis
Question: Analyze the conversion funnel from search to booking.
Answer:
WITH funnel_stages AS (
    SELECT 
        user_id,
        COUNT(*) AS searches,
        SUM(CASE WHEN clicked_listing_ids IS NOT NULL THEN 1 ELSE 0 END) AS searches_with_clicks,
        SUM(CASE WHEN booked_listing_id IS NOT NULL THEN 1 ELSE 0 END) AS searches_with_booking
    FROM search_logs
    GROUP BY user_id
),
funnel_metrics AS (
    SELECT 
        COUNT(DISTINCT user_id) AS total_users,
        SUM(searches) AS total_searches,
        SUM(searches_with_clicks) AS total_clicks,
        SUM(searches_with_booking) AS total_conversions,
        AVG(searches) AS avg_searches_per_user,
        ROUND(100.0 * SUM(searches_with_clicks) / SUM(searches), 2) AS click_through_rate,
        ROUND(100.0 * SUM(searches_with_booking) / SUM(searches_with_clicks), 2) AS booking_rate,
        ROUND(100.0 * SUM(searches_with_booking) / SUM(searches), 2) AS overall_conversion_rate
    FROM funnel_stages
)
SELECT * FROM funnel_metrics;

-- Detailed funnel by destination
WITH destination_funnel AS (
    SELECT 
        destination_city,
        COUNT(*) AS searches,
        COUNT(DISTINCT user_id) AS unique_searchers,
        SUM(CASE WHEN clicked_listing_ids IS NOT NULL THEN 1 ELSE 0 END) AS clicks,
        SUM(CASE WHEN booked_listing_id IS NOT NULL THEN 1 ELSE 0 END) AS bookings
    FROM search_logs
    GROUP BY destination_city
)
SELECT 
    destination_city,
    searches,
    unique_searchers,
    clicks,
    bookings,
    ROUND(100.0 * clicks / searches, 2) AS ctr,
    ROUND(100.0 * bookings / NULLIF(clicks, 0), 2) AS booking_rate,
    ROUND(100.0 * bookings / searches, 2) AS conversion_rate
FROM destination_funnel
ORDER BY searches DESC;

Question 39: Pricing optimization
Question: Identify optimal pricing based on occupancy and revenue.
Answer:
WITH listing_performance AS (
    SELECT 
        l.listing_id,
        l.city,
        l.price_per_night,
        NTILE(5) OVER (PARTITION BY l.city ORDER BY l.price_per_night) AS price_quintile,
        COUNT(DISTINCT b.booking_id) AS bookings,
        SUM(DATEDIFF(b.check_out_date, b.check_in_date)) AS booked_nights,
        SUM(b.total_price) AS total_revenue
    FROM listings l
    LEFT JOIN bookings b ON l.listing_id = b.listing_id 
        AND b.booking_status = 'completed'
    GROUP BY l.listing_id, l.city, l.price_per_night
),
performance_by_price AS (
    SELECT 
        city,
        price_quintile,
        COUNT(*) AS listings_in_quintile,
        AVG(price_per_night) AS avg_price,
        AVG(bookings) AS avg_bookings,
        AVG(booked_nights) AS avg_booked_nights,
        AVG(total_revenue) AS avg_revenue,
        AVG(total_revenue / NULLIF(price_per_night, 0)) AS revenue_multiplier
    FROM listing_performance
    GROUP BY city, price_quintile
)
SELECT 
    city,
    price_quintile,
    listings_in_quintile,
    ROUND(avg_price, 2) AS avg_price,
    ROUND(avg_bookings, 1) AS avg_bookings,
    ROUND(avg_booked_nights, 1) AS avg_nights,
    ROUND(avg_revenue, 2) AS avg_revenue,
    ROUND(revenue_multiplier, 2) AS revenue_efficiency
FROM performance_by_price
ORDER BY city, price_quintile;

Question 40: Superhost impact analysis
Question: Measure the business impact of superhosts vs regular hosts.
Answer:
WITH host_comparison AS (
    SELECT 
        u.is_superhost,
        COUNT(DISTINCT l.listing_id) AS total_listings,
        COUNT(DISTINCT b.booking_id) AS total_bookings,
        SUM(b.total_price) AS total_revenue,
        AVG(b.total_price) AS avg_booking_value,
        AVG(r.overall_rating) AS avg_rating,
        AVG(l.price_per_night) AS avg_nightly_price
    FROM users u
    INNER JOIN listings l ON u.user_id = l.host_id
    LEFT JOIN bookings b ON l.listing_id = b.listing_id 
        AND b.booking_status = 'completed'
    LEFT JOIN reviews r ON b.booking_id = r.booking_id 
        AND r.review_type = 'guest_to_host'
    WHERE u.user_type IN ('host', 'both')
    GROUP BY u.is_superhost
)
SELECT 
    CASE WHEN is_superhost THEN 'Superhost' ELSE 'Regular Host' END AS host_type,
    total_listings,
    total_bookings,
    ROUND(total_bookings * 1.0 / total_listings, 2) AS bookings_per_listing,
    ROUND(total_revenue, 2) AS total_revenue,
    ROUND(avg_booking_value, 2) AS avg_booking_value,
    ROUND(avg_rating, 2) AS avg_rating,
    ROUND(avg_nightly_price, 2) AS avg_price
FROM host_comparison
ORDER BY is_superhost DESC;

Question 41: Geographic expansion opportunities
Question: Identify cities with high demand but low supply.
Answer:
WITH supply_demand AS (
    SELECT 
        s.destination_city AS city,
        COUNT(DISTINCT s.search_id) AS search_volume,
        COUNT(DISTINCT s.user_id) AS unique_searchers,
        COUNT(DISTINCT l.listing_id) AS available_listings,
        AVG(s.max_price) AS avg_max_price_searched
    FROM search_logs s
    LEFT JOIN listings l ON s.destination_city = l.city
    GROUP BY s.destination_city
),
opportunity_score AS (
    SELECT 
        city,
        search_volume,
        unique_searchers,
        available_listings,
        avg_max_price_searched,
        search_volume * 1.0 / NULLIF(available_listings, 0) AS demand_supply_ratio,
        CASE 
            WHEN available_listings = 0 THEN 'No Supply'
            WHEN search_volume * 1.0 / available_listings > 5 THEN 'High Opportunity'
            WHEN search_volume * 1.0 / available_listings > 2 THEN 'Medium Opportunity'
            ELSE 'Saturated Market'
        END AS market_opportunity
    FROM supply_demand
)
SELECT 
    city,
    search_volume,
    unique_searchers,
    COALESCE(available_listings, 0) AS available_listings,
    ROUND(avg_max_price_searched, 2) AS avg_budget,
    ROUND(demand_supply_ratio, 2) AS demand_supply_ratio,
    market_opportunity
FROM opportunity_score
WHERE search_volume >= 2
ORDER BY demand_supply_ratio DESC NULLS LAST;

Question 42: Review text analysis preparation
Question: Prepare review data for text analysis with ratings breakdown.
Answer:
WITH review_analysis AS (
    SELECT 
        r.review_id,
        l.city,
        l.listing_type,
        l.property_type,
        r.overall_rating,
        r.cleanliness_rating,
        r.communication_rating,
        r.checkin_rating,
        r.accuracy_rating,
        r.location_rating,
        r.value_rating,
        LENGTH(r.review_text) AS review_length,
        -- Flag potential issues
        CASE 
            WHEN r.overall_rating <= 3 THEN 'Negative'
            WHEN r.overall_rating = 4 THEN 'Neutral'
            ELSE 'Positive'
        END AS sentiment,
        CASE 
            WHEN r.cleanliness_rating < r.overall_rating THEN 1 ELSE 0 
        END AS cleanliness_issue,
        CASE 
            WHEN r.value_rating < r.overall_rating THEN 1 ELSE 0 
        END AS value_issue,
        CASE 
            WHEN r.communication_rating < r.overall_rating THEN 1 ELSE 0 
        END AS communication_issue
    FROM reviews r
    INNER JOIN bookings b ON r.booking_id = b.booking_id
    INNER JOIN listings l ON b.listing_id = l.listing_id
    WHERE r.review_type = 'guest_to_host'
)
SELECT 
    sentiment,
    COUNT(*) AS review_count,
    AVG(review_length) AS avg_review_length,
    SUM(cleanliness_issue) AS cleanliness_issues,
    SUM(value_issue) AS value_issues,
    SUM(communication_issue) AS communication_issues,
    AVG(overall_rating) AS avg_overall,
    AVG(cleanliness_rating) AS avg_cleanliness,
    AVG(value_rating) AS avg_value
FROM review_analysis
GROUP BY sentiment
ORDER BY avg_overall DESC;

Question 43: Booking lead time analysis
Question: Analyze how far in advance guests book.
Answer:
WITH booking_lead_times AS (
    SELECT 
        b.booking_id,
        l.city,
        l.listing_type,
        b.booking_date,
        b.check_in_date,
        DATEDIFF(b.check_in_date, b.booking_date) AS lead_time_days,
        CASE 
            WHEN DATEDIFF(b.check_in_date, b.booking_date) <= 1 THEN 'Last Minute'
            WHEN DATEDIFF(b.check_in_date, b.booking_date) <= 7 THEN 'Short Notice'
            WHEN DATEDIFF(b.check_in_date, b.booking_date) <= 30 THEN 'Standard'
            ELSE 'Far Advance'
        END AS booking_window,
        b.total_price,
        DATEDIFF(b.check_out_date, b.check_in_date) AS length_of_stay
    FROM bookings b
    INNER JOIN listings l ON b.listing_id = l.listing_id
    WHERE b.booking_status = 'completed'
)
SELECT 
    booking_window,
    COUNT(*) AS booking_count,
    ROUND(100.0 * COUNT(*) / SUM(COUNT(*)) OVER (), 2) AS percentage,
    AVG(lead_time_days) AS avg_lead_days,
    AVG(length_of_stay) AS avg_stay_length,
    AVG(total_price) AS avg_booking_value,
    -- Identify patterns
    SUM(CASE WHEN city = 'San Francisco' THEN 1 ELSE 0 END) AS sf_bookings,
    SUM(CASE WHEN listing_type = 'entire_place' THEN 1 ELSE 0 END) AS entire_place_bookings
FROM booking_lead_times
GROUP BY booking_window
ORDER BY 
    CASE booking_window
        WHEN 'Last Minute' THEN 1
        WHEN 'Short Notice' THEN 2
        WHEN 'Standard' THEN 3
        WHEN 'Far Advance' THEN 4
    END;

Question 44: Host response time impact
Question: Analyze correlation between instant booking and performance.
Answer:
WITH listing_metrics AS (
    SELECT 
        l.listing_id,
        l.instant_bookable,
        COUNT(DISTINCT b.booking_id) AS total_bookings,
        AVG(b.total_price) AS avg_revenue,
        COUNT(DISTINCT CASE WHEN b.booking_status = 'cancelled' THEN b.booking_id END) AS cancellations,
        AVG(r.overall_rating) AS avg_rating,
        AVG(DATEDIFF(b.booking_date, s.search_date)) AS avg_search_to_book_days
    FROM listings l
    LEFT JOIN bookings b ON l.listing_id = b.listing_id
    LEFT JOIN reviews r ON b.booking_id = r.booking_id 
        AND r.review_type = 'guest_to_host'
    LEFT JOIN search_logs s ON b.listing_id = s.booked_listing_id 
        AND b.guest_id = s.user_id
    GROUP BY l.listing_id, l.instant_bookable
)
SELECT 
    instant_bookable,
    COUNT(*) AS listing_count,
    AVG(total_bookings) AS avg_bookings,
    AVG(avg_revenue) AS avg_booking_value,
    ROUND(AVG(cancellations * 100.0 / NULLIF(total_bookings, 0)), 2) AS cancellation_rate,
    ROUND(AVG(avg_rating), 2) AS avg_rating,
    ROUND(AVG(avg_search_to_book_days), 1) AS avg_decision_days
FROM listing_metrics
GROUP BY instant_bookable;

Question 45: Seasonal pricing effectiveness
Question: Analyze if hosts are effectively using seasonal pricing.
Answer:
WITH seasonal_data AS (
    SELECT 
        l.listing_id,
        l.city,
        MONTH(b.check_in_date) AS booking_month,
        CASE 
            WHEN MONTH(b.check_in_date) IN (6, 7, 8) THEN 'Summer'
            WHEN MONTH(b.check_in_date) IN (12, 1, 2) THEN 'Winter'
            WHEN MONTH(b.check_in_date) IN (3, 4, 5) THEN 'Spring'
            ELSE 'Fall'
        END AS season,
        AVG(b.total_price / DATEDIFF(b.check_out_date, b.check_in_date)) AS avg_daily_rate,
        COUNT(*) AS booking_count
    FROM listings l
    INNER JOIN bookings b ON l.listing_id = b.listing_id
    WHERE b.booking_status = 'completed'
    GROUP BY l.listing_id, l.city, booking_month
),
seasonal_variance AS (
    SELECT 
        listing_id,
        city,
        MIN(avg_daily_rate) AS min_rate,
        MAX(avg_daily_rate) AS max_rate,
        AVG(avg_daily_rate) AS mean_rate,
        STDDEV(avg_daily_rate) AS rate_stddev,
        (MAX(avg_daily_rate) - MIN(avg_daily_rate)) / AVG(avg_daily_rate) AS price_variance_ratio
    FROM seasonal_data
    GROUP BY listing_id, city
    HAVING COUNT(DISTINCT season) >= 2
)
SELECT 
    city,
    COUNT(*) AS listings_analyzed,
    ROUND(AVG(price_variance_ratio * 100), 2) AS avg_price_variance_pct,
    ROUND(AVG(min_rate), 2) AS avg_low_season_rate,
    ROUND(AVG(max_rate), 2) AS avg_high_season_rate,
    COUNT(CASE WHEN price_variance_ratio > 0.2 THEN 1 END) AS dynamic_pricing_users,
    COUNT(CASE WHEN price_variance_ratio <= 0.1 THEN 1 END) AS static_pricing_users
FROM seasonal_variance
GROUP BY city
ORDER BY avg_price_variance_pct DESC;


Key Airbnb-Specific Patterns to Remember
1. Marketplace Metrics
Supply and demand balance
Booking conversion rates
Search to booking funnel
Pricing optimization
2. Host Performance
Superhost impact
Revenue per listing
Response time effects
Occupancy rates
3. Guest Behavior
Cohort retention
Booking patterns
Lead time analysis
Repeat guest value
4. Trust & Safety
Review analysis
Cancellation patterns
Guest and host verification
Quality metrics
5. Geographic Analysis
City-level performance
Market saturation
Expansion opportunities
Seasonal patterns
6. Revenue Optimization
Dynamic pricing
Length of stay optimization
Instant booking impact
Business travel segmentation
Interview Tips for Airbnb SQL Questions:
Focus on two-sided marketplace dynamics (hosts and guests)
Consider trust and safety implications in your queries
Think about network effects and how they impact metrics
Remember global scale - consider different markets/cultures
Emphasize data-driven decision making for hosts and the platform
Consider the user journey from search to review
Think about balancing supply and demand efficiently































